// This file is auto-generated by @hey-api/openapi-ts

/**
 * CreateVerifiableCredentialRequestBody contains the request body to request a verifiable credential.
 */
export type CreateVerifiableCredentialRequestBody = {
    format?: string;
    proof?: VerifiableCredentialProof;
    types?: Array<string>;
};

export type DefaultError = unknown;

/**
 * JSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger.
 */
export type JsonRawMessage = unknown;

export type NullBool = boolean | null;

/**
 * Time duration
 * Specify a time duration in milliseconds, seconds, minutes, hours.
 */
export type NullDuration = string;

export type NullInt = number | null;

export type NullString = string | null;

export type NullTime = string | null;

export type NullUuid = string | null;

/**
 * RFC6749ErrorJson is a helper struct for JSON encoding/decoding of RFC6749Error.
 */
export type Rfc6749ErrorJson = {
    error?: string;
    error_debug?: string;
    error_description?: string;
    error_hint?: string;
    status_code?: number;
};

/**
 * StringSliceJSONFormat represents []string{} which is encoded to/from JSON for SQL storage.
 */
export type StringSliceJsonFormat = Array<string>;

export type Time = string;

export type Uuid = string;

/**
 * VerifiableCredentialProof contains the proof of a verifiable credential.
 */
export type VerifiableCredentialProof = {
    jwt?: string;
    proof_type?: string;
};

/**
 * The request payload used to accept a consent request.
 */
export type AcceptOAuth2ConsentRequest = {
    context?: JsonRawMessage;
    grant_access_token_audience?: StringSliceJsonFormat;
    grant_scope?: StringSliceJsonFormat;
    handled_at?: NullTime2;
    /**
     * Remember, if set to true, tells ORY Hydra to remember this consent authorization and reuse it if the same
     * client asks the same user for the same, or a subset of, scope.
     */
    remember?: boolean;
    /**
     * RememberFor sets how long the consent authorization should be remembered for in seconds. If set to `0`, the
     * authorization will be remembered indefinitely.
     */
    remember_for?: number;
    session?: AcceptOAuth2ConsentRequestSession;
};

/**
 * Pass session data to a consent request.
 */
export type AcceptOAuth2ConsentRequestSession = {
    /**
     * AccessToken sets session data for the access and refresh token, as well as any future tokens issued by the
     * refresh grant. Keep in mind that this data will be available to anyone performing OAuth 2.0 Challenge Introspection.
     * If only your services can perform OAuth 2.0 Challenge Introspection, this is usually fine. But if third parties
     * can access that endpoint as well, sensitive data from the session might be exposed to them. Use with care!
     */
    access_token?: unknown;
    /**
     * IDToken sets session data for the OpenID Connect ID token. Keep in mind that the session'id payloads are readable
     * by anyone that has access to the ID Challenge. Use with care!
     */
    id_token?: unknown;
};

/**
 * HandledLoginRequest is the request payload used to accept a login request.
 */
export type AcceptOAuth2LoginRequest = {
    /**
     * ACR sets the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it
     * to express that, for example, a user authenticated using two factor authentication.
     */
    acr?: string;
    amr?: StringSliceJsonFormat;
    context?: JsonRawMessage;
    /**
     * Extend OAuth2 authentication session lifespan
     *
     * If set to `true`, the OAuth2 authentication cookie lifespan is extended. This is for example useful if you want the user to be able to use `prompt=none` continuously.
     *
     * This value can only be set to `true` if the user has an authentication, which is the case if the `skip` value is `true`.
     */
    extend_session_lifespan?: boolean;
    /**
     * ForceSubjectIdentifier forces the "pairwise" user ID of the end-user that authenticated. The "pairwise" user ID refers to the
     * (Pairwise Identifier Algorithm)[http://openid.net/specs/openid-connect-core-1_0.html#PairwiseAlg] of the OpenID
     * Connect specification. It allows you to set an obfuscated subject ("user") identifier that is unique to the client.
     *
     * Please note that this changes the user ID on endpoint /userinfo and sub claim of the ID Token. It does not change the
     * sub claim in the OAuth 2.0 Introspection.
     *
     * Per default, ORY Hydra handles this value with its own algorithm. In case you want to set this yourself
     * you can use this field. Please note that setting this field has no effect if `pairwise` is not configured in
     * ORY Hydra or the OAuth 2.0 Client does not expect a pairwise identifier (set via `subject_type` key in the client's
     * configuration).
     *
     * Please also be aware that ORY Hydra is unable to properly compute this value during authentication. This implies
     * that you have to compute this value on every authentication process (probably depending on the client ID or some
     * other unique value).
     *
     * If you fail to compute the proper value, then authentication processes which have id_token_hint set might fail.
     */
    force_subject_identifier?: string;
    /**
     * IdentityProviderSessionID is the session ID of the end-user that authenticated.
     * If specified, we will use this value to propagate the logout.
     */
    identity_provider_session_id?: string;
    /**
     * Remember, if set to true, tells ORY Hydra to remember this user by telling the user agent (browser) to store
     * a cookie with authentication data. If the same user performs another OAuth 2.0 Authorization Request, he/she
     * will not be asked to log in again.
     */
    remember?: boolean;
    /**
     * RememberFor sets how long the authentication should be remembered for in seconds. If set to `0`, the
     * authorization will be remembered for the duration of the browser session (using a session cookie).
     */
    remember_for?: number;
    /**
     * Subject is the user ID of the end-user that authenticated.
     */
    subject: string;
};

/**
 * Create JSON Web Key Set Request Body
 */
export type CreateJsonWebKeySet = {
    /**
     * JSON Web Key Algorithm
     *
     * The algorithm to be used for creating the key. Supports `RS256`, `ES256`, `ES512`, `HS512`, and `HS256`.
     */
    alg: string;
    /**
     * JSON Web Key ID
     *
     * The Key ID of the key to be created.
     */
    kid: string;
    /**
     * JSON Web Key Use
     *
     * The "use" (public key use) parameter identifies the intended use of
     * the public key. The "use" parameter is employed to indicate whether
     * a public key is used for encrypting data or verifying the signature
     * on data. Valid values are "enc" and "sig".
     */
    use: string;
};

/**
 * Verifiable Credentials Metadata (Draft 00)
 * Includes information about the supported verifiable credentials.
 */
export type CredentialSupportedDraft00 = {
    /**
     * OpenID Connect Verifiable Credentials Cryptographic Binding Methods Supported
     *
     * Contains a list of cryptographic binding methods supported for signing the proof.
     */
    cryptographic_binding_methods_supported?: Array<string>;
    /**
     * OpenID Connect Verifiable Credentials Cryptographic Suites Supported
     *
     * Contains a list of cryptographic suites methods supported for signing the proof.
     */
    cryptographic_suites_supported?: Array<string>;
    /**
     * OpenID Connect Verifiable Credentials Format
     *
     * Contains the format that is supported by this authorization server.
     */
    format?: string;
    /**
     * OpenID Connect Verifiable Credentials Types
     *
     * Contains the types of verifiable credentials supported.
     */
    types?: Array<string>;
};

/**
 * Error
 */
export type ErrorOAuth2 = {
    /**
     * Error
     */
    error?: string;
    /**
     * Error Debug Information
     *
     * Only available in dev mode.
     */
    error_debug?: string;
    /**
     * Error Description
     */
    error_description?: string;
    /**
     * Error Hint
     *
     * Helps the user identify the error cause.
     */
    error_hint?: string;
    /**
     * HTTP Status Code
     */
    status_code?: number;
};

export type GenericError = {
    /**
     * The status code
     */
    code?: number;
    /**
     * Debug information
     *
     * This field is often not exposed to protect against leaking
     * sensitive information.
     */
    debug?: string;
    /**
     * Further error details
     */
    details?: unknown;
    /**
     * The error ID
     *
     * Useful when trying to identify various errors in application logic.
     */
    id?: string;
    /**
     * Error message
     *
     * The error's message.
     */
    message: string;
    /**
     * A human-readable reason for the error
     */
    reason?: string;
    /**
     * The request ID
     *
     * The request ID is often exposed internally in order to trace
     * errors across service architectures. This is often a UUID.
     */
    request?: string;
    /**
     * The status description
     */
    status?: string;
};

/**
 * The not ready status of the service.
 */
export type HealthNotReadyStatus = {
    /**
     * Errors contains a list of errors that caused the not ready status.
     */
    errors?: {
        [key: string]: string;
    };
};

/**
 * The health status of the service.
 */
export type HealthStatus = {
    /**
     * Status always contains "ok".
     */
    status?: string;
};

/**
 * Introspection contains an access token's session data as specified by
 * [IETF RFC 7662](https://tools.ietf.org/html/rfc7662)
 */
export type IntrospectedOAuth2Token = {
    /**
     * Active is a boolean indicator of whether or not the presented token
     * is currently active.  The specifics of a token's "active" state
     * will vary depending on the implementation of the authorization
     * server and the information it keeps about its tokens, but a "true"
     * value return for the "active" property will generally indicate
     * that a given token has been issued by this authorization server,
     * has not been revoked by the resource owner, and is within its
     * given time window of validity (e.g., after its issuance time and
     * before its expiration time).
     */
    active: boolean;
    /**
     * Audience contains a list of the token's intended audiences.
     */
    aud?: Array<string>;
    /**
     * ID is aclient identifier for the OAuth 2.0 client that
     * requested this token.
     */
    client_id?: string;
    /**
     * Expires at is an integer timestamp, measured in the number of seconds
     * since January 1 1970 UTC, indicating when this token will expire.
     */
    exp?: number;
    /**
     * Extra is arbitrary data set by the session.
     */
    ext?: {
        [key: string]: unknown;
    };
    /**
     * Issued at is an integer timestamp, measured in the number of seconds
     * since January 1 1970 UTC, indicating when this token was
     * originally issued.
     */
    iat?: number;
    /**
     * IssuerURL is a string representing the issuer of this token
     */
    iss?: string;
    /**
     * NotBefore is an integer timestamp, measured in the number of seconds
     * since January 1 1970 UTC, indicating when this token is not to be
     * used before.
     */
    nbf?: number;
    /**
     * ObfuscatedSubject is set when the subject identifier algorithm was set to "pairwise" during authorization.
     * It is the `sub` value of the ID Token that was issued.
     */
    obfuscated_subject?: string;
    /**
     * Scope is a JSON string containing a space-separated list of
     * scopes associated with this token.
     */
    scope?: string;
    /**
     * Subject of the token, as defined in JWT [RFC7519].
     * Usually a machine-readable identifier of the resource owner who
     * authorized this token.
     */
    sub?: string;
    /**
     * TokenType is the introspected token's type, typically `Bearer`.
     */
    token_type?: string;
    /**
     * TokenUse is the introspected token's use, for example `access_token` or `refresh_token`.
     */
    token_use?: string;
    /**
     * Username is a human-readable identifier for the resource owner who
     * authorized this token.
     */
    username?: string;
};

/**
 * A JSONPatch document as defined by RFC 6902
 */
export type JsonPatch = {
    /**
     * This field is used together with operation "move" and uses JSON Pointer notation.
     *
     * Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
     */
    from?: string;
    /**
     * The operation to be performed. One of "add", "remove", "replace", "move", "copy", or "test".
     */
    op: string;
    /**
     * The path to the target path. Uses JSON pointer notation.
     *
     * Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
     */
    path: string;
    /**
     * The value to be used within the operations.
     *
     * Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
     */
    value?: unknown;
};

/**
 * A JSONPatchDocument request
 */
export type JsonPatchDocument = Array<JsonPatch>;

export type JsonWebKey = {
    /**
     * The "alg" (algorithm) parameter identifies the algorithm intended for
     * use with the key.  The values used should either be registered in the
     * IANA "JSON Web Signature and Encryption Algorithms" registry
     * established by [JWA] or be a value that contains a Collision-
     * Resistant Name.
     */
    alg: string;
    crv?: string;
    d?: string;
    dp?: string;
    dq?: string;
    e?: string;
    k?: string;
    /**
     * The "kid" (key ID) parameter is used to match a specific key.  This
     * is used, for instance, to choose among a set of keys within a JWK Set
     * during key rollover.  The structure of the "kid" value is
     * unspecified.  When "kid" values are used within a JWK Set, different
     * keys within the JWK Set SHOULD use distinct "kid" values.  (One
     * example in which different keys might use the same "kid" value is if
     * they have different "kty" (key type) values but are considered to be
     * equivalent alternatives by the application using them.)  The "kid"
     * value is a case-sensitive string.
     */
    kid: string;
    /**
     * The "kty" (key type) parameter identifies the cryptographic algorithm
     * family used with the key, such as "RSA" or "EC". "kty" values should
     * either be registered in the IANA "JSON Web Key Types" registry
     * established by [JWA] or be a value that contains a Collision-
     * Resistant Name.  The "kty" value is a case-sensitive string.
     */
    kty: string;
    n?: string;
    p?: string;
    q?: string;
    qi?: string;
    /**
     * Use ("public key use") identifies the intended use of
     * the public key. The "use" parameter is employed to indicate whether
     * a public key is used for encrypting data or verifying the signature
     * on data. Values are commonly "sig" (signature) or "enc" (encryption).
     */
    use: string;
    x?: string;
    /**
     * The "x5c" (X.509 certificate chain) parameter contains a chain of one
     * or more PKIX certificates [RFC5280].  The certificate chain is
     * represented as a JSON array of certificate value strings.  Each
     * string in the array is a base64-encoded (Section 4 of [RFC4648] --
     * not base64url-encoded) DER [ITU.X690.1994] PKIX certificate value.
     * The PKIX certificate containing the key value MUST be the first
     * certificate.
     */
    x5c?: Array<string>;
    y?: string;
};

/**
 * JSON Web Key Set
 */
export type JsonWebKeySet = {
    /**
     * List of JSON Web Keys
     *
     * The value of the "keys" parameter is an array of JSON Web Key (JWK)
     * values. By default, the order of the JWK values within the array does
     * not imply an order of preference among them, although applications
     * of JWK Sets can choose to assign a meaning to the order for their
     * purposes, if desired.
     */
    keys?: Array<JsonWebKey>;
};

export type NullDuration2 = string | null;

export type NullInt64 = number | null;

/**
 * NullTime implements sql.NullTime functionality.
 */
export type NullTime2 = string;

/**
 * OAuth 2.0 Client
 * OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
 * generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
 */
export type OAuth2Client = {
    /**
     * OAuth 2.0 Access Token Strategy
     *
     * AccessTokenStrategy is the strategy used to generate access tokens.
     * Valid options are `jwt` and `opaque`. `jwt` is a bad idea, see https://www.ory.sh/docs/hydra/advanced#json-web-tokens
     * Setting the stragegy here overrides the global setting in `strategies.access_token`.
     */
    access_token_strategy?: string;
    allowed_cors_origins?: StringSliceJsonFormat;
    audience?: StringSliceJsonFormat;
    authorization_code_grant_access_token_lifespan?: NullDuration;
    authorization_code_grant_id_token_lifespan?: NullDuration;
    authorization_code_grant_refresh_token_lifespan?: NullDuration;
    /**
     * OpenID Connect Back-Channel Logout Session Required
     *
     * Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout
     * Token to identify the RP session with the OP when the backchannel_logout_uri is used.
     * If omitted, the default value is false.
     */
    backchannel_logout_session_required?: boolean;
    /**
     * OpenID Connect Back-Channel Logout URI
     *
     * RP URL that will cause the RP to log itself out when sent a Logout Token by the OP.
     */
    backchannel_logout_uri?: string;
    client_credentials_grant_access_token_lifespan?: NullDuration;
    /**
     * OAuth 2.0 Client ID
     *
     * The ID is immutable. If no ID is provided, a UUID4 will be generated.
     */
    client_id?: string;
    /**
     * OAuth 2.0 Client Name
     *
     * The human-readable name of the client to be presented to the
     * end-user during authorization.
     */
    client_name?: string;
    /**
     * OAuth 2.0 Client Secret
     *
     * The secret will be included in the create request as cleartext, and then
     * never again. The secret is kept in hashed format and is not recoverable once lost.
     */
    client_secret?: string;
    /**
     * OAuth 2.0 Client Secret Expires At
     *
     * The field is currently not supported and its value is always 0.
     */
    client_secret_expires_at?: number;
    /**
     * OAuth 2.0 Client URI
     *
     * ClientURI is a URL string of a web page providing information about the client.
     * If present, the server SHOULD display this URL to the end-user in
     * a clickable fashion.
     */
    client_uri?: string;
    contacts?: StringSliceJsonFormat;
    /**
     * OAuth 2.0 Client Creation Date
     *
     * CreatedAt returns the timestamp of the client's creation.
     */
    created_at?: string;
    /**
     * OpenID Connect Front-Channel Logout Session Required
     *
     * Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be
     * included to identify the RP session with the OP when the frontchannel_logout_uri is used.
     * If omitted, the default value is false.
     */
    frontchannel_logout_session_required?: boolean;
    /**
     * OpenID Connect Front-Channel Logout URI
     *
     * RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. An iss (issuer) query
     * parameter and a sid (session ID) query parameter MAY be included by the OP to enable the RP to validate the
     * request and to determine which of the potentially multiple sessions is to be logged out; if either is
     * included, both MUST be.
     */
    frontchannel_logout_uri?: string;
    grant_types?: StringSliceJsonFormat;
    implicit_grant_access_token_lifespan?: NullDuration;
    implicit_grant_id_token_lifespan?: NullDuration;
    /**
     * OAuth 2.0 Client JSON Web Key Set
     *
     * Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as
     * the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter
     * is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for
     * instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client
     * can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation
     * (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks
     * parameters MUST NOT be used together.
     */
    jwks?: unknown;
    /**
     * OAuth 2.0 Client JSON Web Key Set URL
     *
     * URL for the Client's JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains
     * the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the
     * Client's encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing
     * and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced
     * JWK Set to indicate each key's intended usage. Although some algorithms allow the same key to be used for both
     * signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used
     * to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST
     * match those in the certificate.
     */
    jwks_uri?: string;
    jwt_bearer_grant_access_token_lifespan?: NullDuration;
    /**
     * OAuth 2.0 Client Logo URI
     *
     * A URL string referencing the client's logo.
     */
    logo_uri?: string;
    metadata?: JsonRawMessage;
    /**
     * OAuth 2.0 Client Owner
     *
     * Owner is a string identifying the owner of the OAuth 2.0 Client.
     */
    owner?: string;
    /**
     * OAuth 2.0 Client Policy URI
     *
     * PolicyURI is a URL string that points to a human-readable privacy policy document
     * that describes how the deployment organization collects, uses,
     * retains, and discloses personal data.
     */
    policy_uri?: string;
    post_logout_redirect_uris?: StringSliceJsonFormat;
    redirect_uris?: StringSliceJsonFormat;
    refresh_token_grant_access_token_lifespan?: NullDuration;
    refresh_token_grant_id_token_lifespan?: NullDuration;
    refresh_token_grant_refresh_token_lifespan?: NullDuration;
    /**
     * OpenID Connect Dynamic Client Registration Access Token
     *
     * RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client. It is sent when creating a client
     * using Dynamic Client Registration.
     */
    registration_access_token?: string;
    /**
     * OpenID Connect Dynamic Client Registration URL
     *
     * RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client.
     */
    registration_client_uri?: string;
    /**
     * OpenID Connect Request Object Signing Algorithm
     *
     * JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects
     * from this Client MUST be rejected, if not signed with this algorithm.
     */
    request_object_signing_alg?: string;
    request_uris?: StringSliceJsonFormat;
    response_types?: StringSliceJsonFormat;
    /**
     * OAuth 2.0 Client Scope
     *
     * Scope is a string containing a space-separated list of scope values (as
     * described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client
     * can use when requesting access tokens.
     */
    scope?: string;
    /**
     * OpenID Connect Sector Identifier URI
     *
     * URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP. The URL references a
     * file with a single JSON array of redirect_uri values.
     */
    sector_identifier_uri?: string;
    /**
     * SkipConsent skips the consent screen for this client. This field can only
     * be set from the admin API.
     */
    skip_consent?: boolean;
    /**
     * SkipLogoutConsent skips the logout consent screen for this client. This field can only
     * be set from the admin API.
     */
    skip_logout_consent?: boolean;
    /**
     * OpenID Connect Subject Type
     *
     * The `subject_types_supported` Discovery parameter contains a
     * list of the supported subject_type values for this server. Valid types include `pairwise` and `public`.
     */
    subject_type?: string;
    /**
     * OAuth 2.0 Token Endpoint Authentication Method
     *
     * Requested Client Authentication method for the Token Endpoint. The options are:
     *
     * `client_secret_basic`: (default) Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` encoded in the HTTP Authorization header.
     * `client_secret_post`: Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` in the HTTP body.
     * `private_key_jwt`: Use JSON Web Tokens to authenticate the client.
     * `none`: Used for public clients (native apps, mobile apps) which can not have secrets.
     */
    token_endpoint_auth_method?: string;
    /**
     * OAuth 2.0 Token Endpoint Signing Algorithm
     *
     * Requested Client Authentication signing algorithm for the Token Endpoint.
     */
    token_endpoint_auth_signing_alg?: string;
    /**
     * OAuth 2.0 Client Terms of Service URI
     *
     * A URL string pointing to a human-readable terms of service
     * document for the client that describes a contractual relationship
     * between the end-user and the client that the end-user accepts when
     * authorizing the client.
     */
    tos_uri?: string;
    /**
     * OAuth 2.0 Client Last Update Date
     *
     * UpdatedAt returns the timestamp of the last update.
     */
    updated_at?: string;
    /**
     * OpenID Connect Request Userinfo Signed Response Algorithm
     *
     * JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT
     * [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims
     * as a UTF-8 encoded JSON object using the application/json content-type.
     */
    userinfo_signed_response_alg?: string;
};

/**
 * OAuth 2.0 Client Token Lifespans
 * Lifespans of different token types issued for this OAuth 2.0 Client.
 */
export type OAuth2ClientTokenLifespans = {
    authorization_code_grant_access_token_lifespan?: NullDuration;
    authorization_code_grant_id_token_lifespan?: NullDuration;
    authorization_code_grant_refresh_token_lifespan?: NullDuration;
    client_credentials_grant_access_token_lifespan?: NullDuration;
    implicit_grant_access_token_lifespan?: NullDuration;
    implicit_grant_id_token_lifespan?: NullDuration;
    jwt_bearer_grant_access_token_lifespan?: NullDuration;
    refresh_token_grant_access_token_lifespan?: NullDuration;
    refresh_token_grant_id_token_lifespan?: NullDuration;
    refresh_token_grant_refresh_token_lifespan?: NullDuration;
};

/**
 * Contains information on an ongoing consent request.
 */
export type OAuth2ConsentRequest = {
    /**
     * ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it
     * to express that, for example, a user authenticated using two factor authentication.
     */
    acr?: string;
    amr?: StringSliceJsonFormat;
    /**
     * ID is the identifier ("authorization challenge") of the consent authorization request. It is used to
     * identify the session.
     */
    challenge: string;
    client?: OAuth2Client;
    context?: JsonRawMessage;
    /**
     * LoginChallenge is the login challenge this consent challenge belongs to. It can be used to associate
     * a login and consent request in the login & consent app.
     */
    login_challenge?: string;
    /**
     * LoginSessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag)
     * this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false)
     * this will be a new random value. This value is used as the "sid" parameter in the ID Token and in OIDC Front-/Back-
     * channel logout. It's value can generally be used to associate consecutive login requests by a certain user.
     */
    login_session_id?: string;
    oidc_context?: OAuth2ConsentRequestOpenIdConnectContext;
    /**
     * RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which
     * initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but
     * might come in handy if you want to deal with additional request parameters.
     */
    request_url?: string;
    requested_access_token_audience?: StringSliceJsonFormat;
    requested_scope?: StringSliceJsonFormat;
    /**
     * Skip, if true, implies that the client has requested the same scopes from the same user previously.
     * If true, you must not ask the user to grant the requested scopes. You must however either allow or deny the
     * consent request using the usual API call.
     */
    skip?: boolean;
    /**
     * Subject is the user ID of the end-user that authenticated. Now, that end user needs to grant or deny the scope
     * requested by the OAuth 2.0 client.
     */
    subject?: string;
};

/**
 * Contains optional information about the OpenID Connect request.
 */
export type OAuth2ConsentRequestOpenIdConnectContext = {
    /**
     * ACRValues is the Authentication AuthorizationContext Class Reference requested in the OAuth 2.0 Authorization request.
     * It is a parameter defined by OpenID Connect and expresses which level of authentication (e.g. 2FA) is required.
     *
     * OpenID Connect defines it as follows:
     * > Requested Authentication AuthorizationContext Class Reference values. Space-separated string that specifies the acr values
     * that the Authorization Server is being requested to use for processing this Authentication Request, with the
     * values appearing in order of preference. The Authentication AuthorizationContext Class satisfied by the authentication
     * performed is returned as the acr Claim Value, as specified in Section 2. The acr Claim is requested as a
     * Voluntary Claim by this parameter.
     */
    acr_values?: Array<string>;
    /**
     * Display is a string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User.
     * The defined values are:
     * page: The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode.
     * popup: The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over.
     * touch: The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface.
     * wap: The Authorization Server SHOULD display the authentication and consent UI consistent with a "feature phone" type display.
     *
     * The Authorization Server MAY also attempt to detect the capabilities of the User Agent and present an appropriate display.
     */
    display?: string;
    /**
     * IDTokenHintClaims are the claims of the ID Token previously issued by the Authorization Server being passed as a hint about the
     * End-User's current or past authenticated session with the Client.
     */
    id_token_hint_claims?: {
        [key: string]: unknown;
    };
    /**
     * LoginHint hints about the login identifier the End-User might use to log in (if necessary).
     * This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier)
     * and then wants to pass that value as a hint to the discovered authorization service. This value MAY also be a
     * phone number in the format specified for the phone_number Claim. The use of this parameter is optional.
     */
    login_hint?: string;
    /**
     * UILocales is the End-User'id preferred languages and scripts for the user interface, represented as a
     * space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For instance, the value
     * "fr-CA fr en" represents a preference for French as spoken in Canada, then French (without a region designation),
     * followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested
     * locales are not supported by the OpenID Provider.
     */
    ui_locales?: Array<string>;
};

/**
 * OAuth 2.0 Consent Session
 * A completed OAuth 2.0 Consent Session.
 */
export type OAuth2ConsentSession = {
    consent_request?: OAuth2ConsentRequest;
    context?: JsonRawMessage;
    expires_at?: {
        access_token?: string;
        authorize_code?: string;
        id_token?: string;
        par_context?: string;
        refresh_token?: string;
    };
    grant_access_token_audience?: StringSliceJsonFormat;
    grant_scope?: StringSliceJsonFormat;
    handled_at?: NullTime2;
    /**
     * Remember Consent
     *
     * Remember, if set to true, tells ORY Hydra to remember this consent authorization and reuse it if the same
     * client asks the same user for the same, or a subset of, scope.
     */
    remember?: boolean;
    /**
     * Remember Consent For
     *
     * RememberFor sets how long the consent authorization should be remembered for in seconds. If set to `0`, the
     * authorization will be remembered indefinitely.
     */
    remember_for?: number;
    session?: AcceptOAuth2ConsentRequestSession;
};

/**
 * List of OAuth 2.0 Consent Sessions
 */
export type OAuth2ConsentSessions = Array<OAuth2ConsentSession>;

/**
 * Contains information on an ongoing login request.
 */
export type OAuth2LoginRequest = {
    /**
     * ID is the identifier ("login challenge") of the login request. It is used to
     * identify the session.
     */
    challenge: string;
    client: OAuth2Client;
    oidc_context?: OAuth2ConsentRequestOpenIdConnectContext;
    /**
     * RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which
     * initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but
     * might come in handy if you want to deal with additional request parameters.
     */
    request_url: string;
    requested_access_token_audience?: StringSliceJsonFormat;
    requested_scope?: StringSliceJsonFormat;
    /**
     * SessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag)
     * this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false)
     * this will be a new random value. This value is used as the "sid" parameter in the ID Token and in OIDC Front-/Back-
     * channel logout. It's value can generally be used to associate consecutive login requests by a certain user.
     */
    session_id?: string;
    /**
     * Skip, if true, implies that the client has requested the same scopes from the same user previously.
     * If true, you can skip asking the user to grant the requested scopes, and simply forward the user to the redirect URL.
     *
     * This feature allows you to update / set session information.
     */
    skip: boolean;
    /**
     * Subject is the user ID of the end-user that authenticated. Now, that end user needs to grant or deny the scope
     * requested by the OAuth 2.0 client. If this value is set and `skip` is true, you MUST include this subject type
     * when accepting the login request, or the request will fail.
     */
    subject: string;
};

/**
 * Contains information about an ongoing logout request.
 */
export type OAuth2LogoutRequest = {
    /**
     * Challenge is the identifier ("logout challenge") of the logout authentication request. It is used to
     * identify the session.
     */
    challenge?: string;
    client?: OAuth2Client;
    expires_at?: NullTime2;
    /**
     * RequestURL is the original Logout URL requested.
     */
    request_url?: string;
    requested_at?: NullTime2;
    /**
     * RPInitiated is set to true if the request was initiated by a Relying Party (RP), also known as an OAuth 2.0 Client.
     */
    rp_initiated?: boolean;
    /**
     * SessionID is the login session ID that was requested to log out.
     */
    sid?: string;
    /**
     * Subject is the user for whom the logout was request.
     */
    subject?: string;
};

/**
 * OAuth 2.0 Redirect Browser To
 * Contains a redirect URL used to complete a login, consent, or logout request.
 */
export type OAuth2RedirectTo = {
    /**
     * RedirectURL is the URL which you should redirect the user's browser to once the authentication process is completed.
     */
    redirect_to: string;
};

/**
 * OAuth2 Token Exchange Result
 */
export type OAuth2TokenExchange = {
    /**
     * The access token issued by the authorization server.
     */
    access_token?: string;
    /**
     * The lifetime in seconds of the access token. For
     * example, the value "3600" denotes that the access token will
     * expire in one hour from the time the response was generated.
     */
    expires_in?: number;
    /**
     * To retrieve a refresh token request the id_token scope.
     */
    id_token?: string;
    /**
     * The refresh token, which can be used to obtain new
     * access tokens. To retrieve it add the scope "offline" to your access token request.
     */
    refresh_token?: string;
    /**
     * The scope of the access token
     */
    scope?: string;
    /**
     * The type of the token issued
     */
    token_type?: string;
};

/**
 * OpenID Connect Discovery Metadata
 * Includes links to several endpoints (for example `/oauth2/token`) and exposes information on supported signature algorithms
 * among others.
 */
export type OidcConfiguration = {
    /**
     * OAuth 2.0 Authorization Endpoint URL
     */
    authorization_endpoint: string;
    /**
     * OpenID Connect Back-Channel Logout Session Required
     *
     * Boolean value specifying whether the OP can pass a sid (session ID) Claim in the Logout Token to identify the RP
     * session with the OP. If supported, the sid Claim is also included in ID Tokens issued by the OP
     */
    backchannel_logout_session_supported?: boolean;
    /**
     * OpenID Connect Back-Channel Logout Supported
     *
     * Boolean value specifying whether the OP supports back-channel logout, with true indicating support.
     */
    backchannel_logout_supported?: boolean;
    /**
     * OpenID Connect Claims Parameter Parameter Supported
     *
     * Boolean value specifying whether the OP supports use of the claims parameter, with true indicating support.
     */
    claims_parameter_supported?: boolean;
    /**
     * OpenID Connect Supported Claims
     *
     * JSON array containing a list of the Claim Names of the Claims that the OpenID Provider MAY be able to supply
     * values for. Note that for privacy or other reasons, this might not be an exhaustive list.
     */
    claims_supported?: Array<string>;
    /**
     * OAuth 2.0 PKCE Supported Code Challenge Methods
     *
     * JSON array containing a list of Proof Key for Code Exchange (PKCE) [RFC7636] code challenge methods supported
     * by this authorization server.
     */
    code_challenge_methods_supported?: Array<string>;
    /**
     * OpenID Connect Verifiable Credentials Endpoint
     *
     * Contains the URL of the Verifiable Credentials Endpoint.
     */
    credentials_endpoint_draft_00?: string;
    /**
     * OpenID Connect Verifiable Credentials Supported
     *
     * JSON array containing a list of the Verifiable Credentials supported by this authorization server.
     */
    credentials_supported_draft_00?: Array<CredentialSupportedDraft00>;
    /**
     * OpenID Connect End-Session Endpoint
     *
     * URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP.
     */
    end_session_endpoint?: string;
    /**
     * OpenID Connect Front-Channel Logout Session Required
     *
     * Boolean value specifying whether the OP can pass iss (issuer) and sid (session ID) query parameters to identify
     * the RP session with the OP when the frontchannel_logout_uri is used. If supported, the sid Claim is also
     * included in ID Tokens issued by the OP.
     */
    frontchannel_logout_session_supported?: boolean;
    /**
     * OpenID Connect Front-Channel Logout Supported
     *
     * Boolean value specifying whether the OP supports HTTP-based logout, with true indicating support.
     */
    frontchannel_logout_supported?: boolean;
    /**
     * OAuth 2.0 Supported Grant Types
     *
     * JSON array containing a list of the OAuth 2.0 Grant Type values that this OP supports.
     */
    grant_types_supported?: Array<string>;
    /**
     * OpenID Connect Default ID Token Signing Algorithms
     *
     * Algorithm used to sign OpenID Connect ID Tokens.
     */
    id_token_signed_response_alg: Array<string>;
    /**
     * OpenID Connect Supported ID Token Signing Algorithms
     *
     * JSON array containing a list of the JWS signing algorithms (alg values) supported by the OP for the ID Token
     * to encode the Claims in a JWT.
     */
    id_token_signing_alg_values_supported: Array<string>;
    /**
     * OpenID Connect Issuer URL
     *
     * An URL using the https scheme with no query or fragment component that the OP asserts as its IssuerURL Identifier.
     * If IssuerURL discovery is supported , this value MUST be identical to the issuer value returned
     * by WebFinger. This also MUST be identical to the iss Claim value in ID Tokens issued from this IssuerURL.
     */
    issuer: string;
    /**
     * OpenID Connect Well-Known JSON Web Keys URL
     *
     * URL of the OP's JSON Web Key Set [JWK] document. This contains the signing key(s) the RP uses to validate
     * signatures from the OP. The JWK Set MAY also contain the Server's encryption key(s), which are used by RPs
     * to encrypt requests to the Server. When both signing and encryption keys are made available, a use (Key Use)
     * parameter value is REQUIRED for all keys in the referenced JWK Set to indicate each key's intended usage.
     * Although some algorithms allow the same key to be used for both signatures and encryption, doing so is
     * NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509 representations of
     * keys provided. When used, the bare key values MUST still be present and MUST match those in the certificate.
     */
    jwks_uri: string;
    /**
     * OpenID Connect Dynamic Client Registration Endpoint URL
     */
    registration_endpoint?: string;
    /**
     * OpenID Connect Supported Request Object Signing Algorithms
     *
     * JSON array containing a list of the JWS signing algorithms (alg values) supported by the OP for Request Objects,
     * which are described in Section 6.1 of OpenID Connect Core 1.0 [OpenID.Core]. These algorithms are used both when
     * the Request Object is passed by value (using the request parameter) and when it is passed by reference
     * (using the request_uri parameter).
     */
    request_object_signing_alg_values_supported?: Array<string>;
    /**
     * OpenID Connect Request Parameter Supported
     *
     * Boolean value specifying whether the OP supports use of the request parameter, with true indicating support.
     */
    request_parameter_supported?: boolean;
    /**
     * OpenID Connect Request URI Parameter Supported
     *
     * Boolean value specifying whether the OP supports use of the request_uri parameter, with true indicating support.
     */
    request_uri_parameter_supported?: boolean;
    /**
     * OpenID Connect Requires Request URI Registration
     *
     * Boolean value specifying whether the OP requires any request_uri values used to be pre-registered
     * using the request_uris registration parameter.
     */
    require_request_uri_registration?: boolean;
    /**
     * OAuth 2.0 Supported Response Modes
     *
     * JSON array containing a list of the OAuth 2.0 response_mode values that this OP supports.
     */
    response_modes_supported?: Array<string>;
    /**
     * OAuth 2.0 Supported Response Types
     *
     * JSON array containing a list of the OAuth 2.0 response_type values that this OP supports. Dynamic OpenID
     * Providers MUST support the code, id_token, and the token id_token Response Type values.
     */
    response_types_supported: Array<string>;
    /**
     * OAuth 2.0 Token Revocation URL
     *
     * URL of the authorization server's OAuth 2.0 revocation endpoint.
     */
    revocation_endpoint?: string;
    /**
     * OAuth 2.0 Supported Scope Values
     *
     * JSON array containing a list of the OAuth 2.0 [RFC6749] scope values that this server supports. The server MUST
     * support the openid scope value. Servers MAY choose not to advertise some supported scope values even when this parameter is used
     */
    scopes_supported?: Array<string>;
    /**
     * OpenID Connect Supported Subject Types
     *
     * JSON array containing a list of the Subject Identifier types that this OP supports. Valid types include
     * pairwise and public.
     */
    subject_types_supported: Array<string>;
    /**
     * OAuth 2.0 Token Endpoint URL
     */
    token_endpoint: string;
    /**
     * OAuth 2.0 Supported Client Authentication Methods
     *
     * JSON array containing a list of Client Authentication methods supported by this Token Endpoint. The options are
     * client_secret_post, client_secret_basic, client_secret_jwt, and private_key_jwt, as described in Section 9 of OpenID Connect Core 1.0
     */
    token_endpoint_auth_methods_supported?: Array<string>;
    /**
     * OpenID Connect Userinfo URL
     *
     * URL of the OP's UserInfo Endpoint.
     */
    userinfo_endpoint?: string;
    /**
     * OpenID Connect User Userinfo Signing Algorithm
     *
     * Algorithm used to sign OpenID Connect Userinfo Responses.
     */
    userinfo_signed_response_alg: Array<string>;
    /**
     * OpenID Connect Supported Userinfo Signing Algorithm
     *
     * JSON array containing a list of the JWS [JWS] signing algorithms (alg values) [JWA] supported by the UserInfo Endpoint to encode the Claims in a JWT [JWT].
     */
    userinfo_signing_alg_values_supported?: Array<string>;
};

/**
 * OpenID Connect Userinfo
 */
export type OidcUserInfo = {
    /**
     * End-User's birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform's date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
     */
    birthdate?: string;
    /**
     * End-User's preferred e-mail address. Its value MUST conform to the RFC 5322 [RFC5322] addr-spec syntax. The RP MUST NOT rely upon this value being unique, as discussed in Section 5.7.
     */
    email?: string;
    /**
     * True if the End-User's e-mail address has been verified; otherwise false. When this Claim Value is true, this means that the OP took affirmative steps to ensure that this e-mail address was controlled by the End-User at the time the verification was performed. The means by which an e-mail address is verified is context-specific, and dependent upon the trust framework or contractual agreements within which the parties are operating.
     */
    email_verified?: boolean;
    /**
     * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
     */
    family_name?: string;
    /**
     * End-User's gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
     */
    gender?: string;
    /**
     * Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
     */
    given_name?: string;
    /**
     * End-User's locale, represented as a BCP47 [RFC5646] language tag. This is typically an ISO 639-1 Alpha-2 [ISO639‑1] language code in lowercase and an ISO 3166-1 Alpha-2 [ISO3166‑1] country code in uppercase, separated by a dash. For example, en-US or fr-CA. As a compatibility note, some implementations have used an underscore as the separator rather than a dash, for example, en_US; Relying Parties MAY choose to accept this locale syntax as well.
     */
    locale?: string;
    /**
     * Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
     */
    middle_name?: string;
    /**
     * End-User's full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User's locale and preferences.
     */
    name?: string;
    /**
     * Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
     */
    nickname?: string;
    /**
     * End-User's preferred telephone number. E.164 [E.164] is RECOMMENDED as the format of this Claim, for example, +1 (425) 555-1212 or +56 (2) 687 2400. If the phone number contains an extension, it is RECOMMENDED that the extension be represented using the RFC 3966 [RFC3966] extension syntax, for example, +1 (604) 555-1234;ext=5678.
     */
    phone_number?: string;
    /**
     * True if the End-User's phone number has been verified; otherwise false. When this Claim Value is true, this means that the OP took affirmative steps to ensure that this phone number was controlled by the End-User at the time the verification was performed. The means by which a phone number is verified is context-specific, and dependent upon the trust framework or contractual agreements within which the parties are operating. When true, the phone_number Claim MUST be in E.164 format and any extensions MUST be represented in RFC 3966 format.
     */
    phone_number_verified?: boolean;
    /**
     * URL of the End-User's profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
     */
    picture?: string;
    /**
     * Non-unique shorthand name by which the End-User wishes to be referred to at the RP, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace.
     */
    preferred_username?: string;
    /**
     * URL of the End-User's profile page. The contents of this Web page SHOULD be about the End-User.
     */
    profile?: string;
    /**
     * Subject - Identifier for the End-User at the IssuerURL.
     */
    sub?: string;
    /**
     * Time the End-User's information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     */
    updated_at?: number;
    /**
     * URL of the End-User's Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
     */
    website?: string;
    /**
     * String from zoneinfo [zoneinfo] time zone database representing the End-User's time zone. For example, Europe/Paris or America/Los_Angeles.
     */
    zoneinfo?: string;
};

export type Pagination = {
    /**
     * Items per page
     *
     * This is the number of items per page to return.
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     */
    page_size?: number;
    /**
     * Next Page Token
     *
     * The next page token.
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     */
    page_token?: string;
};

export type PaginationHeaders = {
    /**
     * The link header contains pagination links.
     *
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     *
     * in: header
     */
    link?: string;
    /**
     * The total number of clients.
     *
     * in: header
     */
    'x-total-count'?: string;
};

/**
 * The request payload used to accept a login or consent request.
 */
export type RejectOAuth2Request = {
    /**
     * The error should follow the OAuth2 error format (e.g. `invalid_request`, `login_required`).
     *
     * Defaults to `request_denied`.
     */
    error?: string;
    /**
     * Debug contains information to help resolve the problem as a developer. Usually not exposed
     * to the public but only in the server logs.
     */
    error_debug?: string;
    /**
     * Description of the error in a human readable format.
     */
    error_description?: string;
    /**
     * Hint to help resolve the error.
     */
    error_hint?: string;
    /**
     * Represents the HTTP status code of the error (e.g. 401 or 403)
     *
     * Defaults to 400
     */
    status_code?: number;
};

export type TokenPagination = {
    /**
     * Items per page
     *
     * This is the number of items per page to return.
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     */
    page_size?: number;
    /**
     * Next Page Token
     *
     * The next page token.
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     */
    page_token?: string;
};

export type TokenPaginationHeaders = {
    /**
     * The link header contains pagination links.
     *
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     *
     * in: header
     */
    link?: string;
    /**
     * The total number of clients.
     *
     * in: header
     */
    'x-total-count'?: string;
};

/**
 * Pagination Request Parameters
 * The `Link` HTTP header contains multiple links (`first`, `next`, `last`, `previous`) formatted as:
 * `<https://{project-slug}.projects.oryapis.com/admin/clients?page_size={limit}&page_token={offset}>; rel="{page}"`
 *
 * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
 */
export type TokenPaginationRequestParameters = {
    /**
     * Items per Page
     *
     * This is the number of items per page to return.
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     */
    page_size?: number;
    /**
     * Next Page Token
     *
     * The next page token.
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     */
    page_token?: string;
};

/**
 * Pagination Response Header
 * The `Link` HTTP header contains multiple links (`first`, `next`, `last`, `previous`) formatted as:
 * `<https://{project-slug}.projects.oryapis.com/admin/clients?page_size={limit}&page_token={offset}>; rel="{page}"`
 *
 * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
 */
export type TokenPaginationResponseHeaders = {
    /**
     * The Link HTTP Header
     *
     * The `Link` header contains a comma-delimited list of links to the following pages:
     *
     * first: The first page of results.
     * next: The next page of results.
     * prev: The previous page of results.
     * last: The last page of results.
     *
     * Pages are omitted if they do not exist. For example, if there is no next page, the `next` link is omitted. Examples:
     *
     * </clients?page_size=5&page_token=0>; rel="first",</clients?page_size=5&page_token=15>; rel="next",</clients?page_size=5&page_token=5>; rel="prev",</clients?page_size=5&page_token=20>; rel="last"
     */
    link?: string;
    /**
     * The X-Total-Count HTTP Header
     *
     * The `X-Total-Count` header contains the total number of items in the collection.
     */
    'x-total-count'?: number;
};

/**
 * Trust OAuth2 JWT Bearer Grant Type Issuer Request Body
 */
export type TrustOAuth2JwtGrantIssuer = {
    /**
     * The "allow_any_subject" indicates that the issuer is allowed to have any principal as the subject of the JWT.
     */
    allow_any_subject?: boolean;
    /**
     * The "expires_at" indicates, when grant will expire, so we will reject assertion from "issuer" targeting "subject".
     */
    expires_at: string;
    /**
     * The "issuer" identifies the principal that issued the JWT assertion (same as "iss" claim in JWT).
     */
    issuer: string;
    jwk: JsonWebKey;
    /**
     * The "scope" contains list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749])
     */
    scope: Array<string>;
    /**
     * The "subject" identifies the principal that is the subject of the JWT.
     */
    subject?: string;
};

/**
 * OAuth2 JWT Bearer Grant Type Issuer Trust Relationship
 */
export type TrustedOAuth2JwtGrantIssuer = {
    /**
     * The "allow_any_subject" indicates that the issuer is allowed to have any principal as the subject of the JWT.
     */
    allow_any_subject?: boolean;
    /**
     * The "created_at" indicates, when grant was created.
     */
    created_at?: string;
    /**
     * The "expires_at" indicates, when grant will expire, so we will reject assertion from "issuer" targeting "subject".
     */
    expires_at?: string;
    id?: string;
    /**
     * The "issuer" identifies the principal that issued the JWT assertion (same as "iss" claim in JWT).
     */
    issuer?: string;
    public_key?: TrustedOAuth2JwtGrantJsonWebKey;
    /**
     * The "scope" contains list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749])
     */
    scope?: Array<string>;
    /**
     * The "subject" identifies the principal that is the subject of the JWT.
     */
    subject?: string;
};

/**
 * OAuth2 JWT Bearer Grant Type Issuer Trust Relationships
 */
export type TrustedOAuth2JwtGrantIssuers = Array<TrustedOAuth2JwtGrantIssuer>;

/**
 * OAuth2 JWT Bearer Grant Type Issuer Trusted JSON Web Key
 */
export type TrustedOAuth2JwtGrantJsonWebKey = {
    /**
     * The "key_id" is key unique identifier (same as kid header in jws/jwt).
     */
    kid?: string;
    /**
     * The "set" is basically a name for a group(set) of keys. Will be the same as "issuer" in grant.
     */
    set?: string;
};

export type UnexpectedError = string;

/**
 * VerifiableCredentialPrimingResponse contains the nonce to include in the proof-of-possession JWT.
 */
export type VerifiableCredentialPrimingResponse = {
    c_nonce?: string;
    c_nonce_expires_in?: number;
    error?: string;
    error_debug?: string;
    error_description?: string;
    error_hint?: string;
    format?: string;
    status_code?: number;
};

/**
 * VerifiableCredentialResponse contains the verifiable credential.
 */
export type VerifiableCredentialResponse = {
    credential_draft_00?: string;
    format?: string;
};

export type Version = {
    /**
     * Version is the service's version.
     */
    version?: string;
};

export type DiscoverJsonWebKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/.well-known/jwks.json';
};

export type DiscoverJsonWebKeysErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type DiscoverJsonWebKeysError = DiscoverJsonWebKeysErrors[keyof DiscoverJsonWebKeysErrors];

export type DiscoverJsonWebKeysResponses = {
    /**
     * jsonWebKeySet
     */
    200: JsonWebKeySet;
};

export type DiscoverJsonWebKeysResponse = DiscoverJsonWebKeysResponses[keyof DiscoverJsonWebKeysResponses];

export type DiscoverOidcConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/.well-known/openid-configuration';
};

export type DiscoverOidcConfigurationErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type DiscoverOidcConfigurationError = DiscoverOidcConfigurationErrors[keyof DiscoverOidcConfigurationErrors];

export type DiscoverOidcConfigurationResponses = {
    /**
     * oidcConfiguration
     */
    200: OidcConfiguration;
};

export type DiscoverOidcConfigurationResponse = DiscoverOidcConfigurationResponses[keyof DiscoverOidcConfigurationResponses];

export type ListOAuth2ClientsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Items per Page
         *
         * This is the number of items per page to return.
         * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
         */
        page_size?: number;
        /**
         * Next Page Token
         *
         * The next page token.
         * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
         */
        page_token?: string;
        /**
         * The name of the clients to filter by.
         */
        client_name?: string;
        /**
         * The owner of the clients to filter by.
         */
        owner?: string;
    };
    url: '/admin/clients';
};

export type ListOAuth2ClientsErrors = {
    /**
     * Default Error Response
     */
    default: ErrorOAuth2;
};

export type ListOAuth2ClientsError = ListOAuth2ClientsErrors[keyof ListOAuth2ClientsErrors];

export type ListOAuth2ClientsResponses = {
    /**
     * Paginated OAuth2 Client List Response
     */
    200: Array<OAuth2Client>;
};

export type ListOAuth2ClientsResponse = ListOAuth2ClientsResponses[keyof ListOAuth2ClientsResponses];

export type CreateOAuth2ClientData = {
    /**
     * OAuth 2.0 Client Request Body
     */
    body: OAuth2Client;
    path?: never;
    query?: never;
    url: '/admin/clients';
};

export type CreateOAuth2ClientErrors = {
    /**
     * Bad Request Error Response
     */
    400: ErrorOAuth2;
    /**
     * Default Error Response
     */
    default: ErrorOAuth2;
};

export type CreateOAuth2ClientError = CreateOAuth2ClientErrors[keyof CreateOAuth2ClientErrors];

export type CreateOAuth2ClientResponses = {
    /**
     * oAuth2Client
     */
    201: OAuth2Client;
};

export type CreateOAuth2ClientResponse = CreateOAuth2ClientResponses[keyof CreateOAuth2ClientResponses];

export type DeleteOAuth2ClientData = {
    body?: never;
    path: {
        /**
         * The id of the OAuth 2.0 Client.
         */
        id: string;
    };
    query?: never;
    url: '/admin/clients/{id}';
};

export type DeleteOAuth2ClientErrors = {
    /**
     * genericError
     */
    default: GenericError;
};

export type DeleteOAuth2ClientError = DeleteOAuth2ClientErrors[keyof DeleteOAuth2ClientErrors];

export type DeleteOAuth2ClientResponses = {
    /**
     * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     * typically 204.
     */
    204: void;
};

export type DeleteOAuth2ClientResponse = DeleteOAuth2ClientResponses[keyof DeleteOAuth2ClientResponses];

export type GetOAuth2ClientData = {
    body?: never;
    path: {
        /**
         * The id of the OAuth 2.0 Client.
         */
        id: string;
    };
    query?: never;
    url: '/admin/clients/{id}';
};

export type GetOAuth2ClientErrors = {
    /**
     * Default Error Response
     */
    default: ErrorOAuth2;
};

export type GetOAuth2ClientError = GetOAuth2ClientErrors[keyof GetOAuth2ClientErrors];

export type GetOAuth2ClientResponses = {
    /**
     * oAuth2Client
     */
    200: OAuth2Client;
};

export type GetOAuth2ClientResponse = GetOAuth2ClientResponses[keyof GetOAuth2ClientResponses];

export type PatchOAuth2ClientData = {
    /**
     * OAuth 2.0 Client JSON Patch Body
     */
    body: JsonPatchDocument;
    path: {
        /**
         * The id of the OAuth 2.0 Client.
         */
        id: string;
    };
    query?: never;
    url: '/admin/clients/{id}';
};

export type PatchOAuth2ClientErrors = {
    /**
     * Not Found Error Response
     */
    404: ErrorOAuth2;
    /**
     * Default Error Response
     */
    default: ErrorOAuth2;
};

export type PatchOAuth2ClientError = PatchOAuth2ClientErrors[keyof PatchOAuth2ClientErrors];

export type PatchOAuth2ClientResponses = {
    /**
     * oAuth2Client
     */
    200: OAuth2Client;
};

export type PatchOAuth2ClientResponse = PatchOAuth2ClientResponses[keyof PatchOAuth2ClientResponses];

export type SetOAuth2ClientData = {
    /**
     * OAuth 2.0 Client Request Body
     */
    body: OAuth2Client;
    path: {
        /**
         * OAuth 2.0 Client ID
         */
        id: string;
    };
    query?: never;
    url: '/admin/clients/{id}';
};

export type SetOAuth2ClientErrors = {
    /**
     * Bad Request Error Response
     */
    400: ErrorOAuth2;
    /**
     * Not Found Error Response
     */
    404: ErrorOAuth2;
    /**
     * Default Error Response
     */
    default: ErrorOAuth2;
};

export type SetOAuth2ClientError = SetOAuth2ClientErrors[keyof SetOAuth2ClientErrors];

export type SetOAuth2ClientResponses = {
    /**
     * oAuth2Client
     */
    200: OAuth2Client;
};

export type SetOAuth2ClientResponse = SetOAuth2ClientResponses[keyof SetOAuth2ClientResponses];

export type SetOAuth2ClientLifespansData = {
    body?: OAuth2ClientTokenLifespans;
    path: {
        /**
         * OAuth 2.0 Client ID
         */
        id: string;
    };
    query?: never;
    url: '/admin/clients/{id}/lifespans';
};

export type SetOAuth2ClientLifespansErrors = {
    /**
     * genericError
     */
    default: GenericError;
};

export type SetOAuth2ClientLifespansError = SetOAuth2ClientLifespansErrors[keyof SetOAuth2ClientLifespansErrors];

export type SetOAuth2ClientLifespansResponses = {
    /**
     * oAuth2Client
     */
    200: OAuth2Client;
};

export type SetOAuth2ClientLifespansResponse = SetOAuth2ClientLifespansResponses[keyof SetOAuth2ClientLifespansResponses];

export type DeleteJsonWebKeySetData = {
    body?: never;
    path: {
        /**
         * The JSON Web Key Set
         */
        set: string;
    };
    query?: never;
    url: '/admin/keys/{set}';
};

export type DeleteJsonWebKeySetErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type DeleteJsonWebKeySetError = DeleteJsonWebKeySetErrors[keyof DeleteJsonWebKeySetErrors];

export type DeleteJsonWebKeySetResponses = {
    /**
     * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     * typically 204.
     */
    204: void;
};

export type DeleteJsonWebKeySetResponse = DeleteJsonWebKeySetResponses[keyof DeleteJsonWebKeySetResponses];

export type GetJsonWebKeySetData = {
    body?: never;
    path: {
        /**
         * JSON Web Key Set ID
         */
        set: string;
    };
    query?: never;
    url: '/admin/keys/{set}';
};

export type GetJsonWebKeySetErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type GetJsonWebKeySetError = GetJsonWebKeySetErrors[keyof GetJsonWebKeySetErrors];

export type GetJsonWebKeySetResponses = {
    /**
     * jsonWebKeySet
     */
    200: JsonWebKeySet;
};

export type GetJsonWebKeySetResponse = GetJsonWebKeySetResponses[keyof GetJsonWebKeySetResponses];

export type CreateJsonWebKeySetData = {
    body: CreateJsonWebKeySet;
    path: {
        /**
         * The JSON Web Key Set ID
         */
        set: string;
    };
    query?: never;
    url: '/admin/keys/{set}';
};

export type CreateJsonWebKeySetErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type CreateJsonWebKeySetError = CreateJsonWebKeySetErrors[keyof CreateJsonWebKeySetErrors];

export type CreateJsonWebKeySetResponses = {
    /**
     * jsonWebKeySet
     */
    201: JsonWebKeySet;
};

export type CreateJsonWebKeySetResponse = CreateJsonWebKeySetResponses[keyof CreateJsonWebKeySetResponses];

export type SetJsonWebKeySetData = {
    body?: JsonWebKeySet;
    path: {
        /**
         * The JSON Web Key Set ID
         */
        set: string;
    };
    query?: never;
    url: '/admin/keys/{set}';
};

export type SetJsonWebKeySetErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type SetJsonWebKeySetError = SetJsonWebKeySetErrors[keyof SetJsonWebKeySetErrors];

export type SetJsonWebKeySetResponses = {
    /**
     * jsonWebKeySet
     */
    200: JsonWebKeySet;
};

export type SetJsonWebKeySetResponse = SetJsonWebKeySetResponses[keyof SetJsonWebKeySetResponses];

export type DeleteJsonWebKeyData = {
    body?: never;
    path: {
        /**
         * The JSON Web Key Set
         */
        set: string;
        /**
         * The JSON Web Key ID (kid)
         */
        kid: string;
    };
    query?: never;
    url: '/admin/keys/{set}/{kid}';
};

export type DeleteJsonWebKeyErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type DeleteJsonWebKeyError = DeleteJsonWebKeyErrors[keyof DeleteJsonWebKeyErrors];

export type DeleteJsonWebKeyResponses = {
    /**
     * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     * typically 204.
     */
    204: void;
};

export type DeleteJsonWebKeyResponse = DeleteJsonWebKeyResponses[keyof DeleteJsonWebKeyResponses];

export type GetJsonWebKeyData = {
    body?: never;
    path: {
        /**
         * JSON Web Key Set ID
         */
        set: string;
        /**
         * JSON Web Key ID
         */
        kid: string;
    };
    query?: never;
    url: '/admin/keys/{set}/{kid}';
};

export type GetJsonWebKeyErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type GetJsonWebKeyError = GetJsonWebKeyErrors[keyof GetJsonWebKeyErrors];

export type GetJsonWebKeyResponses = {
    /**
     * jsonWebKeySet
     */
    200: JsonWebKeySet;
};

export type GetJsonWebKeyResponse = GetJsonWebKeyResponses[keyof GetJsonWebKeyResponses];

export type SetJsonWebKeyData = {
    body?: JsonWebKey;
    path: {
        /**
         * The JSON Web Key Set ID
         */
        set: string;
        /**
         * JSON Web Key ID
         */
        kid: string;
    };
    query?: never;
    url: '/admin/keys/{set}/{kid}';
};

export type SetJsonWebKeyErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type SetJsonWebKeyError = SetJsonWebKeyErrors[keyof SetJsonWebKeyErrors];

export type SetJsonWebKeyResponses = {
    /**
     * jsonWebKey
     */
    200: JsonWebKey;
};

export type SetJsonWebKeyResponse = SetJsonWebKeyResponses[keyof SetJsonWebKeyResponses];

export type GetOAuth2ConsentRequestData = {
    body?: never;
    path?: never;
    query: {
        /**
         * OAuth 2.0 Consent Request Challenge
         */
        consent_challenge: string;
    };
    url: '/admin/oauth2/auth/requests/consent';
};

export type GetOAuth2ConsentRequestErrors = {
    /**
     * oAuth2RedirectTo
     */
    410: OAuth2RedirectTo;
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type GetOAuth2ConsentRequestError = GetOAuth2ConsentRequestErrors[keyof GetOAuth2ConsentRequestErrors];

export type GetOAuth2ConsentRequestResponses = {
    /**
     * oAuth2ConsentRequest
     */
    200: OAuth2ConsentRequest;
};

export type GetOAuth2ConsentRequestResponse = GetOAuth2ConsentRequestResponses[keyof GetOAuth2ConsentRequestResponses];

export type AcceptOAuth2ConsentRequestData = {
    body?: AcceptOAuth2ConsentRequest;
    path?: never;
    query: {
        /**
         * OAuth 2.0 Consent Request Challenge
         */
        consent_challenge: string;
    };
    url: '/admin/oauth2/auth/requests/consent/accept';
};

export type AcceptOAuth2ConsentRequestErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type AcceptOAuth2ConsentRequestError = AcceptOAuth2ConsentRequestErrors[keyof AcceptOAuth2ConsentRequestErrors];

export type AcceptOAuth2ConsentRequestResponses = {
    /**
     * oAuth2RedirectTo
     */
    200: OAuth2RedirectTo;
};

export type AcceptOAuth2ConsentRequestResponse = AcceptOAuth2ConsentRequestResponses[keyof AcceptOAuth2ConsentRequestResponses];

export type RejectOAuth2ConsentRequestData = {
    body?: RejectOAuth2Request;
    path?: never;
    query: {
        /**
         * OAuth 2.0 Consent Request Challenge
         */
        consent_challenge: string;
    };
    url: '/admin/oauth2/auth/requests/consent/reject';
};

export type RejectOAuth2ConsentRequestErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type RejectOAuth2ConsentRequestError = RejectOAuth2ConsentRequestErrors[keyof RejectOAuth2ConsentRequestErrors];

export type RejectOAuth2ConsentRequestResponses = {
    /**
     * oAuth2RedirectTo
     */
    200: OAuth2RedirectTo;
};

export type RejectOAuth2ConsentRequestResponse = RejectOAuth2ConsentRequestResponses[keyof RejectOAuth2ConsentRequestResponses];

export type GetOAuth2LoginRequestData = {
    body?: never;
    path?: never;
    query: {
        /**
         * OAuth 2.0 Login Request Challenge
         */
        login_challenge: string;
    };
    url: '/admin/oauth2/auth/requests/login';
};

export type GetOAuth2LoginRequestErrors = {
    /**
     * oAuth2RedirectTo
     */
    410: OAuth2RedirectTo;
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type GetOAuth2LoginRequestError = GetOAuth2LoginRequestErrors[keyof GetOAuth2LoginRequestErrors];

export type GetOAuth2LoginRequestResponses = {
    /**
     * oAuth2LoginRequest
     */
    200: OAuth2LoginRequest;
};

export type GetOAuth2LoginRequestResponse = GetOAuth2LoginRequestResponses[keyof GetOAuth2LoginRequestResponses];

export type AcceptOAuth2LoginRequestData = {
    body?: AcceptOAuth2LoginRequest;
    path?: never;
    query: {
        /**
         * OAuth 2.0 Login Request Challenge
         */
        login_challenge: string;
    };
    url: '/admin/oauth2/auth/requests/login/accept';
};

export type AcceptOAuth2LoginRequestErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type AcceptOAuth2LoginRequestError = AcceptOAuth2LoginRequestErrors[keyof AcceptOAuth2LoginRequestErrors];

export type AcceptOAuth2LoginRequestResponses = {
    /**
     * oAuth2RedirectTo
     */
    200: OAuth2RedirectTo;
};

export type AcceptOAuth2LoginRequestResponse = AcceptOAuth2LoginRequestResponses[keyof AcceptOAuth2LoginRequestResponses];

export type RejectOAuth2LoginRequestData = {
    body?: RejectOAuth2Request;
    path?: never;
    query: {
        /**
         * OAuth 2.0 Login Request Challenge
         */
        login_challenge: string;
    };
    url: '/admin/oauth2/auth/requests/login/reject';
};

export type RejectOAuth2LoginRequestErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type RejectOAuth2LoginRequestError = RejectOAuth2LoginRequestErrors[keyof RejectOAuth2LoginRequestErrors];

export type RejectOAuth2LoginRequestResponses = {
    /**
     * oAuth2RedirectTo
     */
    200: OAuth2RedirectTo;
};

export type RejectOAuth2LoginRequestResponse = RejectOAuth2LoginRequestResponses[keyof RejectOAuth2LoginRequestResponses];

export type GetOAuth2LogoutRequestData = {
    body?: never;
    path?: never;
    query: {
        logout_challenge: string;
    };
    url: '/admin/oauth2/auth/requests/logout';
};

export type GetOAuth2LogoutRequestErrors = {
    /**
     * oAuth2RedirectTo
     */
    410: OAuth2RedirectTo;
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type GetOAuth2LogoutRequestError = GetOAuth2LogoutRequestErrors[keyof GetOAuth2LogoutRequestErrors];

export type GetOAuth2LogoutRequestResponses = {
    /**
     * oAuth2LogoutRequest
     */
    200: OAuth2LogoutRequest;
};

export type GetOAuth2LogoutRequestResponse = GetOAuth2LogoutRequestResponses[keyof GetOAuth2LogoutRequestResponses];

export type AcceptOAuth2LogoutRequestData = {
    body?: never;
    path?: never;
    query: {
        /**
         * OAuth 2.0 Logout Request Challenge
         */
        logout_challenge: string;
    };
    url: '/admin/oauth2/auth/requests/logout/accept';
};

export type AcceptOAuth2LogoutRequestErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type AcceptOAuth2LogoutRequestError = AcceptOAuth2LogoutRequestErrors[keyof AcceptOAuth2LogoutRequestErrors];

export type AcceptOAuth2LogoutRequestResponses = {
    /**
     * oAuth2RedirectTo
     */
    200: OAuth2RedirectTo;
};

export type AcceptOAuth2LogoutRequestResponse = AcceptOAuth2LogoutRequestResponses[keyof AcceptOAuth2LogoutRequestResponses];

export type RejectOAuth2LogoutRequestData = {
    body?: never;
    path?: never;
    query: {
        logout_challenge: string;
    };
    url: '/admin/oauth2/auth/requests/logout/reject';
};

export type RejectOAuth2LogoutRequestErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type RejectOAuth2LogoutRequestError = RejectOAuth2LogoutRequestErrors[keyof RejectOAuth2LogoutRequestErrors];

export type RejectOAuth2LogoutRequestResponses = {
    /**
     * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     * typically 204.
     */
    204: void;
};

export type RejectOAuth2LogoutRequestResponse = RejectOAuth2LogoutRequestResponses[keyof RejectOAuth2LogoutRequestResponses];

export type RevokeOAuth2ConsentSessionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * OAuth 2.0 Consent Subject
         *
         * The subject whose consent sessions should be deleted.
         */
        subject: string;
        /**
         * OAuth 2.0 Client ID
         *
         * If set, deletes only those consent sessions that have been granted to the specified OAuth 2.0 Client ID.
         */
        client?: string;
        /**
         * Revoke All Consent Sessions
         *
         * If set to `true` deletes all consent sessions by the Subject that have been granted.
         */
        all?: boolean;
    };
    url: '/admin/oauth2/auth/sessions/consent';
};

export type RevokeOAuth2ConsentSessionsErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type RevokeOAuth2ConsentSessionsError = RevokeOAuth2ConsentSessionsErrors[keyof RevokeOAuth2ConsentSessionsErrors];

export type RevokeOAuth2ConsentSessionsResponses = {
    /**
     * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     * typically 204.
     */
    204: void;
};

export type RevokeOAuth2ConsentSessionsResponse = RevokeOAuth2ConsentSessionsResponses[keyof RevokeOAuth2ConsentSessionsResponses];

export type ListOAuth2ConsentSessionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Items per Page
         *
         * This is the number of items per page to return.
         * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
         */
        page_size?: number;
        /**
         * Next Page Token
         *
         * The next page token.
         * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
         */
        page_token?: string;
        /**
         * The subject to list the consent sessions for.
         */
        subject: string;
        /**
         * The login session id to list the consent sessions for.
         */
        login_session_id?: string;
    };
    url: '/admin/oauth2/auth/sessions/consent';
};

export type ListOAuth2ConsentSessionsErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type ListOAuth2ConsentSessionsError = ListOAuth2ConsentSessionsErrors[keyof ListOAuth2ConsentSessionsErrors];

export type ListOAuth2ConsentSessionsResponses = {
    /**
     * oAuth2ConsentSessions
     */
    200: OAuth2ConsentSessions;
};

export type ListOAuth2ConsentSessionsResponse = ListOAuth2ConsentSessionsResponses[keyof ListOAuth2ConsentSessionsResponses];

export type RevokeOAuth2LoginSessionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * OAuth 2.0 Subject
         *
         * The subject to revoke authentication sessions for.
         */
        subject?: string;
        /**
         * Login Session ID
         *
         * The login session to revoke.
         */
        sid?: string;
    };
    url: '/admin/oauth2/auth/sessions/login';
};

export type RevokeOAuth2LoginSessionsErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type RevokeOAuth2LoginSessionsError = RevokeOAuth2LoginSessionsErrors[keyof RevokeOAuth2LoginSessionsErrors];

export type RevokeOAuth2LoginSessionsResponses = {
    /**
     * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     * typically 204.
     */
    204: void;
};

export type RevokeOAuth2LoginSessionsResponse = RevokeOAuth2LoginSessionsResponses[keyof RevokeOAuth2LoginSessionsResponses];

export type IntrospectOAuth2TokenData = {
    body?: {
        /**
         * An optional, space separated list of required scopes. If the access token was not granted one of the
         * scopes, the result of active will be false.
         */
        scope?: string;
        /**
         * The string value of the token. For access tokens, this
         * is the "access_token" value returned from the token endpoint
         * defined in OAuth 2.0. For refresh tokens, this is the "refresh_token"
         * value returned.
         */
        token: string;
    };
    path?: never;
    query?: never;
    url: '/admin/oauth2/introspect';
};

export type IntrospectOAuth2TokenErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type IntrospectOAuth2TokenError = IntrospectOAuth2TokenErrors[keyof IntrospectOAuth2TokenErrors];

export type IntrospectOAuth2TokenResponses = {
    /**
     * introspectedOAuth2Token
     */
    200: IntrospectedOAuth2Token;
};

export type IntrospectOAuth2TokenResponse = IntrospectOAuth2TokenResponses[keyof IntrospectOAuth2TokenResponses];

export type DeleteOAuth2TokenData = {
    body?: never;
    path?: never;
    query: {
        /**
         * OAuth 2.0 Client ID
         */
        client_id: string;
    };
    url: '/admin/oauth2/tokens';
};

export type DeleteOAuth2TokenErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type DeleteOAuth2TokenError = DeleteOAuth2TokenErrors[keyof DeleteOAuth2TokenErrors];

export type DeleteOAuth2TokenResponses = {
    /**
     * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     * typically 204.
     */
    204: void;
};

export type DeleteOAuth2TokenResponse = DeleteOAuth2TokenResponses[keyof DeleteOAuth2TokenResponses];

export type ListTrustedOAuth2JwtGrantIssuersData = {
    body?: never;
    path?: never;
    query?: {
        MaxItems?: number;
        DefaultItems?: number;
        /**
         * If optional "issuer" is supplied, only jwt-bearer grants with this issuer will be returned.
         */
        issuer?: string;
    };
    url: '/admin/trust/grants/jwt-bearer/issuers';
};

export type ListTrustedOAuth2JwtGrantIssuersErrors = {
    /**
     * genericError
     */
    default: GenericError;
};

export type ListTrustedOAuth2JwtGrantIssuersError = ListTrustedOAuth2JwtGrantIssuersErrors[keyof ListTrustedOAuth2JwtGrantIssuersErrors];

export type ListTrustedOAuth2JwtGrantIssuersResponses = {
    /**
     * trustedOAuth2JwtGrantIssuers
     */
    200: TrustedOAuth2JwtGrantIssuers;
};

export type ListTrustedOAuth2JwtGrantIssuersResponse = ListTrustedOAuth2JwtGrantIssuersResponses[keyof ListTrustedOAuth2JwtGrantIssuersResponses];

export type TrustOAuth2JwtGrantIssuerData = {
    body?: TrustOAuth2JwtGrantIssuer;
    path?: never;
    query?: never;
    url: '/admin/trust/grants/jwt-bearer/issuers';
};

export type TrustOAuth2JwtGrantIssuerErrors = {
    /**
     * genericError
     */
    default: GenericError;
};

export type TrustOAuth2JwtGrantIssuerError = TrustOAuth2JwtGrantIssuerErrors[keyof TrustOAuth2JwtGrantIssuerErrors];

export type TrustOAuth2JwtGrantIssuerResponses = {
    /**
     * trustedOAuth2JwtGrantIssuer
     */
    201: TrustedOAuth2JwtGrantIssuer;
};

export type TrustOAuth2JwtGrantIssuerResponse = TrustOAuth2JwtGrantIssuerResponses[keyof TrustOAuth2JwtGrantIssuerResponses];

export type DeleteTrustedOAuth2JwtGrantIssuerData = {
    body?: never;
    path: {
        /**
         * The id of the desired grant
         */
        id: string;
    };
    query?: never;
    url: '/admin/trust/grants/jwt-bearer/issuers/{id}';
};

export type DeleteTrustedOAuth2JwtGrantIssuerErrors = {
    /**
     * genericError
     */
    default: GenericError;
};

export type DeleteTrustedOAuth2JwtGrantIssuerError = DeleteTrustedOAuth2JwtGrantIssuerErrors[keyof DeleteTrustedOAuth2JwtGrantIssuerErrors];

export type DeleteTrustedOAuth2JwtGrantIssuerResponses = {
    /**
     * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     * typically 204.
     */
    204: void;
};

export type DeleteTrustedOAuth2JwtGrantIssuerResponse = DeleteTrustedOAuth2JwtGrantIssuerResponses[keyof DeleteTrustedOAuth2JwtGrantIssuerResponses];

export type GetTrustedOAuth2JwtGrantIssuerData = {
    body?: never;
    path: {
        /**
         * The id of the desired grant
         */
        id: string;
    };
    query?: never;
    url: '/admin/trust/grants/jwt-bearer/issuers/{id}';
};

export type GetTrustedOAuth2JwtGrantIssuerErrors = {
    /**
     * genericError
     */
    default: GenericError;
};

export type GetTrustedOAuth2JwtGrantIssuerError = GetTrustedOAuth2JwtGrantIssuerErrors[keyof GetTrustedOAuth2JwtGrantIssuerErrors];

export type GetTrustedOAuth2JwtGrantIssuerResponses = {
    /**
     * trustedOAuth2JwtGrantIssuer
     */
    200: TrustedOAuth2JwtGrantIssuer;
};

export type GetTrustedOAuth2JwtGrantIssuerResponse = GetTrustedOAuth2JwtGrantIssuerResponses[keyof GetTrustedOAuth2JwtGrantIssuerResponses];

export type CreateVerifiableCredentialData = {
    body?: CreateVerifiableCredentialRequestBody;
    path?: never;
    query?: never;
    url: '/credentials';
};

export type CreateVerifiableCredentialErrors = {
    /**
     * verifiableCredentialPrimingResponse
     */
    400: VerifiableCredentialPrimingResponse;
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type CreateVerifiableCredentialError = CreateVerifiableCredentialErrors[keyof CreateVerifiableCredentialErrors];

export type CreateVerifiableCredentialResponses = {
    /**
     * verifiableCredentialResponse
     */
    200: VerifiableCredentialResponse;
};

export type CreateVerifiableCredentialResponse = CreateVerifiableCredentialResponses[keyof CreateVerifiableCredentialResponses];

export type IsAliveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health/alive';
};

export type IsAliveErrors = {
    /**
     * genericError
     */
    500: GenericError;
};

export type IsAliveError = IsAliveErrors[keyof IsAliveErrors];

export type IsAliveResponses = {
    /**
     * Ory Hydra is ready to accept connections.
     */
    200: HealthStatus;
};

export type IsAliveResponse = IsAliveResponses[keyof IsAliveResponses];

export type IsReadyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health/ready';
};

export type IsReadyErrors = {
    /**
     * Ory Kratos is not yet ready to accept requests.
     */
    503: {
        /**
         * Errors contains a list of errors that caused the not ready status.
         */
        errors?: {
            [key: string]: string;
        };
    };
};

export type IsReadyError = IsReadyErrors[keyof IsReadyErrors];

export type IsReadyResponses = {
    /**
     * Ory Hydra is ready to accept requests.
     */
    200: {
        /**
         * Always "ok".
         */
        status?: string;
    };
};

export type IsReadyResponse = IsReadyResponses[keyof IsReadyResponses];

export type OAuth2AuthorizeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/oauth2/auth';
};

export type OAuth2AuthorizeErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type OAuth2AuthorizeError = OAuth2AuthorizeErrors[keyof OAuth2AuthorizeErrors];

export type OAuth2AuthorizeResponses = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type OAuth2AuthorizeResponse = OAuth2AuthorizeResponses[keyof OAuth2AuthorizeResponses];

export type CreateOidcDynamicClientData = {
    /**
     * Dynamic Client Registration Request Body
     */
    body: OAuth2Client;
    path?: never;
    query?: never;
    url: '/oauth2/register';
};

export type CreateOidcDynamicClientErrors = {
    /**
     * Bad Request Error Response
     */
    400: ErrorOAuth2;
    /**
     * Default Error Response
     */
    default: ErrorOAuth2;
};

export type CreateOidcDynamicClientError = CreateOidcDynamicClientErrors[keyof CreateOidcDynamicClientErrors];

export type CreateOidcDynamicClientResponses = {
    /**
     * oAuth2Client
     */
    201: OAuth2Client;
};

export type CreateOidcDynamicClientResponse = CreateOidcDynamicClientResponses[keyof CreateOidcDynamicClientResponses];

export type DeleteOidcDynamicClientData = {
    body?: never;
    path: {
        /**
         * The id of the OAuth 2.0 Client.
         */
        id: string;
    };
    query?: never;
    url: '/oauth2/register/{id}';
};

export type DeleteOidcDynamicClientErrors = {
    /**
     * genericError
     */
    default: GenericError;
};

export type DeleteOidcDynamicClientError = DeleteOidcDynamicClientErrors[keyof DeleteOidcDynamicClientErrors];

export type DeleteOidcDynamicClientResponses = {
    /**
     * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     * typically 204.
     */
    204: void;
};

export type DeleteOidcDynamicClientResponse = DeleteOidcDynamicClientResponses[keyof DeleteOidcDynamicClientResponses];

export type GetOidcDynamicClientData = {
    body?: never;
    path: {
        /**
         * The id of the OAuth 2.0 Client.
         */
        id: string;
    };
    query?: never;
    url: '/oauth2/register/{id}';
};

export type GetOidcDynamicClientErrors = {
    /**
     * Default Error Response
     */
    default: ErrorOAuth2;
};

export type GetOidcDynamicClientError = GetOidcDynamicClientErrors[keyof GetOidcDynamicClientErrors];

export type GetOidcDynamicClientResponses = {
    /**
     * oAuth2Client
     */
    200: OAuth2Client;
};

export type GetOidcDynamicClientResponse = GetOidcDynamicClientResponses[keyof GetOidcDynamicClientResponses];

export type SetOidcDynamicClientData = {
    /**
     * OAuth 2.0 Client Request Body
     */
    body: OAuth2Client;
    path: {
        /**
         * OAuth 2.0 Client ID
         */
        id: string;
    };
    query?: never;
    url: '/oauth2/register/{id}';
};

export type SetOidcDynamicClientErrors = {
    /**
     * Not Found Error Response
     */
    404: ErrorOAuth2;
    /**
     * Default Error Response
     */
    default: ErrorOAuth2;
};

export type SetOidcDynamicClientError = SetOidcDynamicClientErrors[keyof SetOidcDynamicClientErrors];

export type SetOidcDynamicClientResponses = {
    /**
     * oAuth2Client
     */
    200: OAuth2Client;
};

export type SetOidcDynamicClientResponse = SetOidcDynamicClientResponses[keyof SetOidcDynamicClientResponses];

export type RevokeOAuth2TokenData = {
    body?: {
        client_id?: string;
        client_secret?: string;
        token: string;
    };
    path?: never;
    query?: never;
    url: '/oauth2/revoke';
};

export type RevokeOAuth2TokenErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type RevokeOAuth2TokenError = RevokeOAuth2TokenErrors[keyof RevokeOAuth2TokenErrors];

export type RevokeOAuth2TokenResponses = {
    /**
     * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     * typically 204.
     */
    200: unknown;
};

export type RevokeOidcSessionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/oauth2/sessions/logout';
};

export type Oauth2TokenExchangeData = {
    body?: {
        client_id?: string;
        code?: string;
        grant_type: string;
        redirect_uri?: string;
        refresh_token?: string;
    };
    path?: never;
    query?: never;
    url: '/oauth2/token';
};

export type Oauth2TokenExchangeErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type Oauth2TokenExchangeError = Oauth2TokenExchangeErrors[keyof Oauth2TokenExchangeErrors];

export type Oauth2TokenExchangeResponses = {
    /**
     * oAuth2TokenExchange
     */
    200: OAuth2TokenExchange;
};

export type Oauth2TokenExchangeResponse = Oauth2TokenExchangeResponses[keyof Oauth2TokenExchangeResponses];

export type GetOidcUserInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/userinfo';
};

export type GetOidcUserInfoErrors = {
    /**
     * errorOAuth2
     */
    default: ErrorOAuth2;
};

export type GetOidcUserInfoError = GetOidcUserInfoErrors[keyof GetOidcUserInfoErrors];

export type GetOidcUserInfoResponses = {
    /**
     * oidcUserInfo
     */
    200: OidcUserInfo;
};

export type GetOidcUserInfoResponse = GetOidcUserInfoResponses[keyof GetOidcUserInfoResponses];

export type GetVersionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/version';
};

export type GetVersionResponses = {
    /**
     * Returns the Ory Hydra version.
     */
    200: {
        /**
         * The version of Ory Hydra.
         */
        version?: string;
    };
};

export type GetVersionResponse = GetVersionResponses[keyof GetVersionResponses];

export type ClientOptions = {
    baseURL: 'https://raw.githubusercontent.com' | (string & {});
};