// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, Composable, TDataShape, Client } from './client';
import type { GetWebAuthnJavaScriptResponse, GetWebAuthnJavaScriptData, ListCourierMessagesResponse, ListCourierMessagesData, ListCourierMessagesError, GetCourierMessageResponse, GetCourierMessageData, GetCourierMessageError, ListIdentitiesResponse, ListIdentitiesData, ListIdentitiesError, BatchPatchIdentitiesResponse2, BatchPatchIdentitiesData, BatchPatchIdentitiesError, CreateIdentityResponse, CreateIdentityData, CreateIdentityError, DeleteIdentityResponse, DeleteIdentityData, DeleteIdentityError, GetIdentityResponse, GetIdentityData, GetIdentityError, PatchIdentityResponse, PatchIdentityData, PatchIdentityError, UpdateIdentityResponse, UpdateIdentityData, UpdateIdentityError, DeleteIdentityCredentialsResponse, DeleteIdentityCredentialsData, DeleteIdentityCredentialsError, DeleteIdentitySessionsResponse, DeleteIdentitySessionsData, DeleteIdentitySessionsError, ListIdentitySessionsResponse, ListIdentitySessionsData, ListIdentitySessionsError, CreateRecoveryCodeForIdentityResponse, CreateRecoveryCodeForIdentityData, CreateRecoveryCodeForIdentityError, CreateRecoveryLinkForIdentityResponse, CreateRecoveryLinkForIdentityData, CreateRecoveryLinkForIdentityError, ListSessionsResponse, ListSessionsData, ListSessionsError, DisableSessionResponse, DisableSessionData, DisableSessionError, GetSessionResponse, GetSessionData, GetSessionError, ExtendSessionResponse, ExtendSessionData, ExtendSessionError, IsAliveResponse, IsAliveData, IsAliveError, IsReadyResponse, IsReadyData, IsReadyError, ListIdentitySchemasResponse, ListIdentitySchemasData, ListIdentitySchemasError, GetIdentitySchemaResponse, GetIdentitySchemaData, GetIdentitySchemaError, GetFlowErrorResponse, GetFlowErrorData, GetFlowErrorError, CreateFedcmFlowResponse2, CreateFedcmFlowData, CreateFedcmFlowError, UpdateFedcmFlowResponse, UpdateFedcmFlowData, UpdateFedcmFlowError, UpdateLoginFlowResponse, UpdateLoginFlowData, UpdateLoginFlowError, CreateNativeLoginFlowResponse, CreateNativeLoginFlowData, CreateNativeLoginFlowError, CreateBrowserLoginFlowResponse, CreateBrowserLoginFlowData, CreateBrowserLoginFlowError, GetLoginFlowResponse, GetLoginFlowData, GetLoginFlowError, UpdateLogoutFlowResponse, UpdateLogoutFlowData, UpdateLogoutFlowError, PerformNativeLogoutResponse, PerformNativeLogoutData, PerformNativeLogoutError, CreateBrowserLogoutFlowResponse, CreateBrowserLogoutFlowData, CreateBrowserLogoutFlowError, UpdateRecoveryFlowResponse, UpdateRecoveryFlowData, UpdateRecoveryFlowError, CreateNativeRecoveryFlowResponse, CreateNativeRecoveryFlowData, CreateNativeRecoveryFlowError, CreateBrowserRecoveryFlowResponse, CreateBrowserRecoveryFlowData, CreateBrowserRecoveryFlowError, GetRecoveryFlowResponse, GetRecoveryFlowData, GetRecoveryFlowError, UpdateRegistrationFlowResponse, UpdateRegistrationFlowData, UpdateRegistrationFlowError, CreateNativeRegistrationFlowResponse, CreateNativeRegistrationFlowData, CreateNativeRegistrationFlowError, CreateBrowserRegistrationFlowResponse, CreateBrowserRegistrationFlowData, CreateBrowserRegistrationFlowError, GetRegistrationFlowResponse, GetRegistrationFlowData, GetRegistrationFlowError, UpdateSettingsFlowResponse, UpdateSettingsFlowData, UpdateSettingsFlowError, CreateNativeSettingsFlowResponse, CreateNativeSettingsFlowData, CreateNativeSettingsFlowError, CreateBrowserSettingsFlowResponse, CreateBrowserSettingsFlowData, CreateBrowserSettingsFlowError, GetSettingsFlowResponse, GetSettingsFlowData, GetSettingsFlowError, UpdateVerificationFlowResponse, UpdateVerificationFlowData, UpdateVerificationFlowError, CreateNativeVerificationFlowResponse, CreateNativeVerificationFlowData, CreateNativeVerificationFlowError, CreateBrowserVerificationFlowResponse, CreateBrowserVerificationFlowData, CreateBrowserVerificationFlowError, GetVerificationFlowResponse, GetVerificationFlowData, GetVerificationFlowError, DisableMyOtherSessionsResponse, DisableMyOtherSessionsData, DisableMyOtherSessionsError, ListMySessionsResponse, ListMySessionsData, ListMySessionsError, ExchangeSessionTokenResponse, ExchangeSessionTokenData, ExchangeSessionTokenError, ToSessionResponse, ToSessionData, ToSessionError, DisableMySessionResponse, DisableMySessionData, DisableMySessionError, GetVersionResponse, GetVersionData } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TComposable extends Composable, TData extends TDataShape = TDataShape, ResT = unknown, DefaultT = undefined> = ClientOptions<TComposable, TData, ResT, DefaultT> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Get WebAuthn JavaScript
 * This endpoint provides JavaScript which is needed in order to perform WebAuthn login and registration.
 *
 * If you are building a JavaScript Browser App (e.g. in ReactJS or AngularJS) you will need to load this file:
 *
 * ```html
 * <script src="https://public-kratos.example.org/.well-known/ory/webauthn.js" type="script" async />
 * ```
 *
 * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
 */
export const getWebAuthnJavaScript = <TComposable extends Composable, DefaultT extends GetWebAuthnJavaScriptResponse = GetWebAuthnJavaScriptResponse>(options: Options<TComposable, GetWebAuthnJavaScriptData, GetWebAuthnJavaScriptResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetWebAuthnJavaScriptResponse | DefaultT, unknown, DefaultT>({
        url: '/.well-known/ory/webauthn.js',
        ...options
    });
};

/**
 * List Messages
 * Lists all messages by given status and recipient.
 */
export const listCourierMessages = <TComposable extends Composable, DefaultT extends ListCourierMessagesResponse = ListCourierMessagesResponse>(options: Options<TComposable, ListCourierMessagesData, ListCourierMessagesResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, ListCourierMessagesResponse | DefaultT, ListCourierMessagesError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/courier/messages',
        ...options
    });
};

/**
 * Get a Message
 * Gets a specific messages by the given ID.
 */
export const getCourierMessage = <TComposable extends Composable, DefaultT extends GetCourierMessageResponse = GetCourierMessageResponse>(options: Options<TComposable, GetCourierMessageData, GetCourierMessageResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetCourierMessageResponse | DefaultT, GetCourierMessageError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/courier/messages/{id}',
        ...options
    });
};

/**
 * List Identities
 * Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system. Note: filters cannot be combined.
 */
export const listIdentities = <TComposable extends Composable, DefaultT extends ListIdentitiesResponse = ListIdentitiesResponse>(options: Options<TComposable, ListIdentitiesData, ListIdentitiesResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, ListIdentitiesResponse | DefaultT, ListIdentitiesError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/identities',
        ...options
    });
};

/**
 * Create multiple identities
 * Creates multiple
 * [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model).
 * This endpoint can also be used to [import
 * credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities)
 * for instance passwords, social sign in configurations or multifactor methods.
 */
export const batchPatchIdentities = <TComposable extends Composable, DefaultT extends BatchPatchIdentitiesResponse2 = BatchPatchIdentitiesResponse2>(options: Options<TComposable, BatchPatchIdentitiesData, BatchPatchIdentitiesResponse2, DefaultT>) => {
    return (options.client ?? _heyApiClient).patch<TComposable, BatchPatchIdentitiesResponse2 | DefaultT, BatchPatchIdentitiesError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/identities',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create an Identity
 * Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to
 * [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities)
 * for instance passwords, social sign in configurations or multifactor methods.
 */
export const createIdentity = <TComposable extends Composable, DefaultT extends CreateIdentityResponse = CreateIdentityResponse>(options: Options<TComposable, CreateIdentityData, CreateIdentityResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).post<TComposable, CreateIdentityResponse | DefaultT, CreateIdentityError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/identities',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete an Identity
 * Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone.
 * This endpoint returns 204 when the identity was deleted or when the identity was not found, in which case it is
 * assumed that is has been deleted already.
 */
export const deleteIdentity = <TComposable extends Composable, DefaultT extends DeleteIdentityResponse = DeleteIdentityResponse>(options: Options<TComposable, DeleteIdentityData, DeleteIdentityResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).delete<TComposable, DeleteIdentityResponse | DefaultT, DeleteIdentityError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/identities/{id}',
        ...options
    });
};

/**
 * Get an Identity
 * Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally
 * include credentials (e.g. social sign in connections) in the response by using the `include_credential` query parameter.
 */
export const getIdentity = <TComposable extends Composable, DefaultT extends GetIdentityResponse = GetIdentityResponse>(options: Options<TComposable, GetIdentityData, GetIdentityResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetIdentityResponse | DefaultT, GetIdentityError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/identities/{id}',
        ...options
    });
};

/**
 * Patch an Identity
 * Partially updates an [identity's](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/).
 * The fields `id`, `stateChangedAt` and `credentials` can not be updated using this method.
 */
export const patchIdentity = <TComposable extends Composable, DefaultT extends PatchIdentityResponse = PatchIdentityResponse>(options: Options<TComposable, PatchIdentityData, PatchIdentityResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).patch<TComposable, PatchIdentityResponse | DefaultT, PatchIdentityError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/identities/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Update an Identity
 * This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity
 * payload (except credentials) is expected. It is possible to update the identity's credentials as well.
 */
export const updateIdentity = <TComposable extends Composable, DefaultT extends UpdateIdentityResponse = UpdateIdentityResponse>(options: Options<TComposable, UpdateIdentityData, UpdateIdentityResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).put<TComposable, UpdateIdentityResponse | DefaultT, UpdateIdentityError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/identities/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a credential for a specific identity
 * Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type.
 * You cannot delete password or code auth credentials through this API.
 */
export const deleteIdentityCredentials = <TComposable extends Composable, DefaultT extends DeleteIdentityCredentialsResponse = DeleteIdentityCredentialsResponse>(options: Options<TComposable, DeleteIdentityCredentialsData, DeleteIdentityCredentialsResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).delete<TComposable, DeleteIdentityCredentialsResponse | DefaultT, DeleteIdentityCredentialsError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/identities/{id}/credentials/{type}',
        ...options
    });
};

/**
 * Delete & Invalidate an Identity's Sessions
 * Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
 */
export const deleteIdentitySessions = <TComposable extends Composable, DefaultT extends DeleteIdentitySessionsResponse = DeleteIdentitySessionsResponse>(options: Options<TComposable, DeleteIdentitySessionsData, DeleteIdentitySessionsResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).delete<TComposable, DeleteIdentitySessionsResponse | DefaultT, DeleteIdentitySessionsError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/identities/{id}/sessions',
        ...options
    });
};

/**
 * List an Identity's Sessions
 * This endpoint returns all sessions that belong to the given Identity.
 */
export const listIdentitySessions = <TComposable extends Composable, DefaultT extends ListIdentitySessionsResponse = ListIdentitySessionsResponse>(options: Options<TComposable, ListIdentitySessionsData, ListIdentitySessionsResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, ListIdentitySessionsResponse | DefaultT, ListIdentitySessionsError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/identities/{id}/sessions',
        ...options
    });
};

/**
 * Create a Recovery Code
 * This endpoint creates a recovery code which should be given to the user in order for them to recover
 * (or activate) their account.
 */
export const createRecoveryCodeForIdentity = <TComposable extends Composable, DefaultT extends CreateRecoveryCodeForIdentityResponse = CreateRecoveryCodeForIdentityResponse>(options: Options<TComposable, CreateRecoveryCodeForIdentityData, CreateRecoveryCodeForIdentityResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).post<TComposable, CreateRecoveryCodeForIdentityResponse | DefaultT, CreateRecoveryCodeForIdentityError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/recovery/code',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create a Recovery Link
 * This endpoint creates a recovery link which should be given to the user in order for them to recover
 * (or activate) their account.
 */
export const createRecoveryLinkForIdentity = <TComposable extends Composable, DefaultT extends CreateRecoveryLinkForIdentityResponse = CreateRecoveryLinkForIdentityResponse>(options: Options<TComposable, CreateRecoveryLinkForIdentityData, CreateRecoveryLinkForIdentityResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).post<TComposable, CreateRecoveryLinkForIdentityResponse | DefaultT, CreateRecoveryLinkForIdentityError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/recovery/link',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List All Sessions
 * Listing all sessions that exist.
 */
export const listSessions = <TComposable extends Composable, DefaultT extends ListSessionsResponse = ListSessionsResponse>(options: Options<TComposable, ListSessionsData, ListSessionsResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, ListSessionsResponse | DefaultT, ListSessionsError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/sessions',
        ...options
    });
};

/**
 * Deactivate a Session
 * Calling this endpoint deactivates the specified session. Session data is not deleted.
 */
export const disableSession = <TComposable extends Composable, DefaultT extends DisableSessionResponse = DisableSessionResponse>(options: Options<TComposable, DisableSessionData, DisableSessionResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).delete<TComposable, DisableSessionResponse | DefaultT, DisableSessionError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/sessions/{id}',
        ...options
    });
};

/**
 * Get Session
 * This endpoint is useful for:
 *
 * Getting a session object with all specified expandables that exist in an administrative context.
 */
export const getSession = <TComposable extends Composable, DefaultT extends GetSessionResponse = GetSessionResponse>(options: Options<TComposable, GetSessionData, GetSessionResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetSessionResponse | DefaultT, GetSessionError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/sessions/{id}',
        ...options
    });
};

/**
 * Extend a Session
 * Calling this endpoint extends the given session ID. If `session.earliest_possible_extend` is set it
 * will only extend the session after the specified time has passed.
 *
 * This endpoint returns per default a 204 No Content response on success. Older Ory Network projects may
 * return a 200 OK response with the session in the body. Returning the session as part of the response
 * will be deprecated in the future and should not be relied upon.
 *
 * This endpoint ignores consecutive requests to extend the same session and returns a 404 error in those
 * scenarios. This endpoint also returns 404 errors if the session does not exist.
 *
 * Retrieve the session ID from the `/sessions/whoami` endpoint / `toSession` SDK method.
 */
export const extendSession = <TComposable extends Composable, DefaultT extends ExtendSessionResponse = ExtendSessionResponse>(options: Options<TComposable, ExtendSessionData, ExtendSessionResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).patch<TComposable, ExtendSessionResponse | DefaultT, ExtendSessionError, DefaultT>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/admin/sessions/{id}/extend',
        ...options
    });
};

/**
 * Check HTTP Server Status
 * This endpoint returns a HTTP 200 status code when Ory Kratos is accepting incoming
 * HTTP requests. This status does currently not include checks whether the database connection is working.
 *
 * If the service supports TLS Edge Termination, this endpoint does not require the
 * `X-Forwarded-Proto` header to be set.
 *
 * Be aware that if you are running multiple nodes of this service, the health status will never
 * refer to the cluster state, only to a single instance.
 */
export const isAlive = <TComposable extends Composable, DefaultT extends IsAliveResponse = IsAliveResponse>(options: Options<TComposable, IsAliveData, IsAliveResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, IsAliveResponse | DefaultT, IsAliveError, DefaultT>({
        url: '/health/alive',
        ...options
    });
};

/**
 * Check HTTP Server and Database Status
 * This endpoint returns a HTTP 200 status code when Ory Kratos is up running and the environment dependencies (e.g.
 * the database) are responsive as well.
 *
 * If the service supports TLS Edge Termination, this endpoint does not require the
 * `X-Forwarded-Proto` header to be set.
 *
 * Be aware that if you are running multiple nodes of Ory Kratos, the health status will never
 * refer to the cluster state, only to a single instance.
 */
export const isReady = <TComposable extends Composable, DefaultT extends IsReadyResponse = IsReadyResponse>(options: Options<TComposable, IsReadyData, IsReadyResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, IsReadyResponse | DefaultT, IsReadyError, DefaultT>({
        url: '/health/ready',
        ...options
    });
};

/**
 * Get all Identity Schemas
 * Returns a list of all identity schemas currently in use.
 */
export const listIdentitySchemas = <TComposable extends Composable, DefaultT extends ListIdentitySchemasResponse = ListIdentitySchemasResponse>(options: Options<TComposable, ListIdentitySchemasData, ListIdentitySchemasResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, ListIdentitySchemasResponse | DefaultT, ListIdentitySchemasError, DefaultT>({
        url: '/schemas',
        ...options
    });
};

/**
 * Get Identity JSON Schema
 * Return a specific identity schema.
 */
export const getIdentitySchema = <TComposable extends Composable, DefaultT extends GetIdentitySchemaResponse = GetIdentitySchemaResponse>(options: Options<TComposable, GetIdentitySchemaData, GetIdentitySchemaResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetIdentitySchemaResponse | DefaultT, GetIdentitySchemaError, DefaultT>({
        url: '/schemas/{id}',
        ...options
    });
};

/**
 * Get User-Flow Errors
 * This endpoint returns the error associated with a user-facing self service errors.
 *
 * This endpoint supports stub values to help you implement the error UI:
 *
 * `?id=stub:500` - returns a stub 500 (Internal Server Error) error.
 *
 * More information can be found at [Ory Kratos User User Facing Error Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-facing-errors).
 */
export const getFlowError = <TComposable extends Composable, DefaultT extends GetFlowErrorResponse = GetFlowErrorResponse>(options: Options<TComposable, GetFlowErrorData, GetFlowErrorResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetFlowErrorResponse | DefaultT, GetFlowErrorError, DefaultT>({
        url: '/self-service/errors',
        ...options
    });
};

/**
 * Get FedCM Parameters
 * This endpoint returns a list of all available FedCM providers. It is only supported on the Ory Network.
 */
export const createFedcmFlow = <TComposable extends Composable, DefaultT extends CreateFedcmFlowResponse2 = CreateFedcmFlowResponse2>(options: Options<TComposable, CreateFedcmFlowData, CreateFedcmFlowResponse2, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateFedcmFlowResponse2 | DefaultT, CreateFedcmFlowError, DefaultT>({
        url: '/self-service/fed-cm/parameters',
        ...options
    });
};

/**
 * Submit a FedCM token
 * Use this endpoint to submit a token from a FedCM provider through
 * `navigator.credentials.get` and log the user in. The parameters from
 * `navigator.credentials.get` must have come from `GET
 * self-service/fed-cm/parameters`.
 */
export const updateFedcmFlow = <TComposable extends Composable, DefaultT extends UpdateFedcmFlowResponse = UpdateFedcmFlowResponse>(options: Options<TComposable, UpdateFedcmFlowData, UpdateFedcmFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).post<TComposable, UpdateFedcmFlowResponse | DefaultT, UpdateFedcmFlowError, DefaultT>({
        url: '/self-service/fed-cm/token',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Submit a Login Flow
 * Use this endpoint to complete a login flow. This endpoint
 * behaves differently for API and browser flows.
 *
 * API flows expect `application/json` to be sent in the body and responds with
 * HTTP 200 and a application/json body with the session token on success;
 * HTTP 410 if the original flow expired with the appropriate error messages set and optionally a `use_flow_id` parameter in the body;
 * HTTP 400 on form validation errors.
 *
 * Browser flows expect a Content-Type of `application/x-www-form-urlencoded` or `application/json` to be sent in the body and respond with
 * a HTTP 303 redirect to the post/after login URL or the `return_to` value if it was set and if the login succeeded;
 * a HTTP 303 redirect to the login UI URL with the flow ID containing the validation errors otherwise.
 *
 * Browser flows with an accept header of `application/json` will not redirect but instead respond with
 * HTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success;
 * HTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set;
 * HTTP 400 on form validation errors.
 *
 * If this endpoint is called with `Accept: application/json` in the header, the response contains the flow without a redirect. In the
 * case of an error, the `error.id` of the JSON response body can be one of:
 *
 * `session_already_available`: The user is already signed in.
 * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
 * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
 * `browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL.
 * Most likely used in Social Sign In flows.
 *
 * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
 */
export const updateLoginFlow = <TComposable extends Composable, DefaultT extends UpdateLoginFlowResponse = UpdateLoginFlowResponse>(options: Options<TComposable, UpdateLoginFlowData, UpdateLoginFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).post<TComposable, UpdateLoginFlowResponse | DefaultT, UpdateLoginFlowError, DefaultT>({
        url: '/self-service/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create Login Flow for Native Apps
 * This endpoint initiates a login flow for native apps that do not use a browser, such as mobile devices, smart TVs, and so on.
 *
 * If a valid provided session cookie or session token is provided, a 400 Bad Request error
 * will be returned unless the URL query parameter `?refresh=true` is set.
 *
 * To fetch an existing login flow call `/self-service/login/flows?flow=<flow_id>`.
 *
 * You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
 * Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
 * you vulnerable to a variety of CSRF attacks, including CSRF login attacks.
 *
 * In the case of an error, the `error.id` of the JSON response body can be one of:
 *
 * `session_already_available`: The user is already signed in.
 * `session_aal1_required`: Multi-factor auth (e.g. 2fa) was requested but the user has no session yet.
 * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
 *
 * This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
 *
 * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
 */
export const createNativeLoginFlow = <TComposable extends Composable, DefaultT extends CreateNativeLoginFlowResponse = CreateNativeLoginFlowResponse>(options: Options<TComposable, CreateNativeLoginFlowData, CreateNativeLoginFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateNativeLoginFlowResponse | DefaultT, CreateNativeLoginFlowError, DefaultT>({
        url: '/self-service/login/api',
        ...options
    });
};

/**
 * Create Login Flow for Browsers
 * This endpoint initializes a browser-based user login flow. This endpoint will set the appropriate
 * cookies and anti-CSRF measures required for browser-based flows.
 *
 * If this endpoint is opened as a link in the browser, it will be redirected to
 * `selfservice.flows.login.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session
 * exists already, the browser will be redirected to `urls.default_redirect_url` unless the query parameter
 * `?refresh=true` was set.
 *
 * If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the
 * case of an error, the `error.id` of the JSON response body can be one of:
 *
 * `session_already_available`: The user is already signed in.
 * `session_aal1_required`: Multi-factor auth (e.g. 2fa) was requested but the user has no session yet.
 * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
 * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
 *
 * The optional query parameter login_challenge is set when using Kratos with
 * Hydra in an OAuth2 flow. See the oauth2_provider.url configuration
 * option.
 *
 * This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.
 *
 * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
 */
export const createBrowserLoginFlow = <TComposable extends Composable, DefaultT extends CreateBrowserLoginFlowResponse = CreateBrowserLoginFlowResponse>(options: Options<TComposable, CreateBrowserLoginFlowData, CreateBrowserLoginFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateBrowserLoginFlowResponse | DefaultT, CreateBrowserLoginFlowError, DefaultT>({
        url: '/self-service/login/browser',
        ...options
    });
};

/**
 * Get Login Flow
 * This endpoint returns a login flow's context with, for example, error details and other information.
 *
 * Browser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.
 * For AJAX requests you must ensure that cookies are included in the request or requests will fail.
 *
 * If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain
 * and you need to forward the incoming HTTP Cookie header to this endpoint:
 *
 * ```js
 * pseudo-code example
 * router.get('/login', async function (req, res) {
 * const flow = await client.getLoginFlow(req.header('cookie'), req.query['flow'])
 *
 * res.render('login', flow)
 * })
 * ```
 *
 * This request may fail due to several reasons. The `error.id` can be one of:
 *
 * `session_already_available`: The user is already signed in.
 * `self_service_flow_expired`: The flow is expired and you should request a new one.
 *
 * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
 */
export const getLoginFlow = <TComposable extends Composable, DefaultT extends GetLoginFlowResponse = GetLoginFlowResponse>(options: Options<TComposable, GetLoginFlowData, GetLoginFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetLoginFlowResponse | DefaultT, GetLoginFlowError, DefaultT>({
        url: '/self-service/login/flows',
        ...options
    });
};

/**
 * Update Logout Flow
 * This endpoint logs out an identity in a self-service manner.
 *
 * If the `Accept` HTTP header is not set to `application/json`, the browser will be redirected (HTTP 303 See Other)
 * to the `return_to` parameter of the initial request or fall back to `urls.default_return_to`.
 *
 * If the `Accept` HTTP header is set to `application/json`, a 204 No Content response
 * will be sent on successful logout instead.
 *
 * This endpoint is NOT INTENDED for API clients and only works
 * with browsers (Chrome, Firefox, ...). For API clients you can
 * call the `/self-service/logout/api` URL directly with the Ory Session Token.
 *
 * More information can be found at [Ory Kratos User Logout Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-logout).
 */
export const updateLogoutFlow = <TComposable extends Composable, DefaultT extends UpdateLogoutFlowResponse = UpdateLogoutFlowResponse>(options: Options<TComposable, UpdateLogoutFlowData, UpdateLogoutFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, UpdateLogoutFlowResponse | DefaultT, UpdateLogoutFlowError, DefaultT>({
        url: '/self-service/logout',
        ...options
    });
};

/**
 * Perform Logout for Native Apps
 * Use this endpoint to log out an identity using an Ory Session Token. If the Ory Session Token was successfully
 * revoked, the server returns a 204 No Content response. A 204 No Content response is also sent when
 * the Ory Session Token has been revoked already before.
 *
 * If the Ory Session Token is malformed or does not exist a 403 Forbidden response will be returned.
 *
 * This endpoint does not remove any HTTP
 * Cookies - use the Browser-Based Self-Service Logout Flow instead.
 */
export const performNativeLogout = <TComposable extends Composable, DefaultT extends PerformNativeLogoutResponse = PerformNativeLogoutResponse>(options: Options<TComposable, PerformNativeLogoutData, PerformNativeLogoutResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).delete<TComposable, PerformNativeLogoutResponse | DefaultT, PerformNativeLogoutError, DefaultT>({
        url: '/self-service/logout/api',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create a Logout URL for Browsers
 * This endpoint initializes a browser-based user logout flow and a URL which can be used to log out the user.
 *
 * This endpoint is NOT INTENDED for API clients and only works
 * with browsers (Chrome, Firefox, ...). For API clients you can
 * call the `/self-service/logout/api` URL directly with the Ory Session Token.
 *
 * The URL is only valid for the currently signed in user. If no user is signed in, this endpoint returns
 * a 401 error.
 *
 * When calling this endpoint from a backend, please ensure to properly forward the HTTP cookies.
 */
export const createBrowserLogoutFlow = <TComposable extends Composable, DefaultT extends CreateBrowserLogoutFlowResponse = CreateBrowserLogoutFlowResponse>(options: Options<TComposable, CreateBrowserLogoutFlowData, CreateBrowserLogoutFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateBrowserLogoutFlowResponse | DefaultT, CreateBrowserLogoutFlowError, DefaultT>({
        url: '/self-service/logout/browser',
        ...options
    });
};

/**
 * Update Recovery Flow
 * Use this endpoint to update a recovery flow. This endpoint
 * behaves differently for API and browser flows and has several states:
 *
 * `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent
 * and works with API- and Browser-initiated flows.
 * For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid.
 * and a HTTP 303 See Other redirect with a fresh recovery flow if the flow was otherwise invalid (e.g. expired).
 * For Browser clients without HTTP Header `Accept` or with `Accept: text*` it returns a HTTP 303 See Other redirect to the Recovery UI URL with the Recovery Flow ID appended.
 * `sent_email` is the success state after `choose_method` for the `link` method and allows the user to request another recovery email. It
 * works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state.
 * `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow ("sending a recovery link")
 * does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL
 * (if the link was valid) and instructs the user to update their password, or a redirect to the Recover UI URL with
 * a new Recovery Flow ID which contains an error message that the recovery link was invalid.
 *
 * More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
 */
export const updateRecoveryFlow = <TComposable extends Composable, DefaultT extends UpdateRecoveryFlowResponse = UpdateRecoveryFlowResponse>(options: Options<TComposable, UpdateRecoveryFlowData, UpdateRecoveryFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).post<TComposable, UpdateRecoveryFlowResponse | DefaultT, UpdateRecoveryFlowError, DefaultT>({
        url: '/self-service/recovery',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create Recovery Flow for Native Apps
 * This endpoint initiates a recovery flow for API clients such as mobile devices, smart TVs, and so on.
 *
 * If a valid provided session cookie or session token is provided, a 400 Bad Request error.
 *
 * On an existing recovery flow, use the `getRecoveryFlow` API endpoint.
 *
 * You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
 * Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
 * you vulnerable to a variety of CSRF attacks.
 *
 * This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
 *
 * More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
 */
export const createNativeRecoveryFlow = <TComposable extends Composable, DefaultT extends CreateNativeRecoveryFlowResponse = CreateNativeRecoveryFlowResponse>(options: Options<TComposable, CreateNativeRecoveryFlowData, CreateNativeRecoveryFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateNativeRecoveryFlowResponse | DefaultT, CreateNativeRecoveryFlowError, DefaultT>({
        url: '/self-service/recovery/api',
        ...options
    });
};

/**
 * Create Recovery Flow for Browsers
 * This endpoint initializes a browser-based account recovery flow. Once initialized, the browser will be redirected to
 * `selfservice.flows.recovery.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session
 * exists, the browser is returned to the configured return URL.
 *
 * If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects
 * or a 400 bad request error if the user is already authenticated.
 *
 * This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.
 *
 * More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
 */
export const createBrowserRecoveryFlow = <TComposable extends Composable, DefaultT extends CreateBrowserRecoveryFlowResponse = CreateBrowserRecoveryFlowResponse>(options: Options<TComposable, CreateBrowserRecoveryFlowData, CreateBrowserRecoveryFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateBrowserRecoveryFlowResponse | DefaultT, CreateBrowserRecoveryFlowError, DefaultT>({
        url: '/self-service/recovery/browser',
        ...options
    });
};

/**
 * Get Recovery Flow
 * This endpoint returns a recovery flow's context with, for example, error details and other information.
 *
 * Browser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.
 * For AJAX requests you must ensure that cookies are included in the request or requests will fail.
 *
 * If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain
 * and you need to forward the incoming HTTP Cookie header to this endpoint:
 *
 * ```js
 * pseudo-code example
 * router.get('/recovery', async function (req, res) {
 * const flow = await client.getRecoveryFlow(req.header('Cookie'), req.query['flow'])
 *
 * res.render('recovery', flow)
 * })
 * ```
 *
 * More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
 */
export const getRecoveryFlow = <TComposable extends Composable, DefaultT extends GetRecoveryFlowResponse = GetRecoveryFlowResponse>(options: Options<TComposable, GetRecoveryFlowData, GetRecoveryFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetRecoveryFlowResponse | DefaultT, GetRecoveryFlowError, DefaultT>({
        url: '/self-service/recovery/flows',
        ...options
    });
};

/**
 * Update Registration Flow
 * Use this endpoint to complete a registration flow by sending an identity's traits and password. This endpoint
 * behaves differently for API and browser flows.
 *
 * API flows expect `application/json` to be sent in the body and respond with
 * HTTP 200 and a application/json body with the created identity success - if the session hook is configured the
 * `session` and `session_token` will also be included;
 * HTTP 410 if the original flow expired with the appropriate error messages set and optionally a `use_flow_id` parameter in the body;
 * HTTP 400 on form validation errors.
 *
 * Browser flows expect a Content-Type of `application/x-www-form-urlencoded` or `application/json` to be sent in the body and respond with
 * a HTTP 303 redirect to the post/after registration URL or the `return_to` value if it was set and if the registration succeeded;
 * a HTTP 303 redirect to the registration UI URL with the flow ID containing the validation errors otherwise.
 *
 * Browser flows with an accept header of `application/json` will not redirect but instead respond with
 * HTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success;
 * HTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set;
 * HTTP 400 on form validation errors.
 *
 * If this endpoint is called with `Accept: application/json` in the header, the response contains the flow without a redirect. In the
 * case of an error, the `error.id` of the JSON response body can be one of:
 *
 * `session_already_available`: The user is already signed in.
 * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
 * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
 * `browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL.
 * Most likely used in Social Sign In flows.
 *
 * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
 */
export const updateRegistrationFlow = <TComposable extends Composable, DefaultT extends UpdateRegistrationFlowResponse = UpdateRegistrationFlowResponse>(options: Options<TComposable, UpdateRegistrationFlowData, UpdateRegistrationFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).post<TComposable, UpdateRegistrationFlowResponse | DefaultT, UpdateRegistrationFlowError, DefaultT>({
        url: '/self-service/registration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create Registration Flow for Native Apps
 * This endpoint initiates a registration flow for API clients such as mobile devices, smart TVs, and so on.
 *
 * If a valid provided session cookie or session token is provided, a 400 Bad Request error
 * will be returned unless the URL query parameter `?refresh=true` is set.
 *
 * To fetch an existing registration flow call `/self-service/registration/flows?flow=<flow_id>`.
 *
 * You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
 * Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
 * you vulnerable to a variety of CSRF attacks.
 *
 * In the case of an error, the `error.id` of the JSON response body can be one of:
 *
 * `session_already_available`: The user is already signed in.
 * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
 *
 * This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
 *
 * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
 */
export const createNativeRegistrationFlow = <TComposable extends Composable, DefaultT extends CreateNativeRegistrationFlowResponse = CreateNativeRegistrationFlowResponse>(options: Options<TComposable, CreateNativeRegistrationFlowData, CreateNativeRegistrationFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateNativeRegistrationFlowResponse | DefaultT, CreateNativeRegistrationFlowError, DefaultT>({
        url: '/self-service/registration/api',
        ...options
    });
};

/**
 * Create Registration Flow for Browsers
 * This endpoint initializes a browser-based user registration flow. This endpoint will set the appropriate
 * cookies and anti-CSRF measures required for browser-based flows.
 *
 * If this endpoint is opened as a link in the browser, it will be redirected to
 * `selfservice.flows.registration.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session
 * exists already, the browser will be redirected to `urls.default_redirect_url`.
 *
 * If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the
 * case of an error, the `error.id` of the JSON response body can be one of:
 *
 * `session_already_available`: The user is already signed in.
 * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
 * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
 *
 * If this endpoint is called via an AJAX request, the response contains the registration flow without a redirect.
 *
 * This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.
 *
 * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
 */
export const createBrowserRegistrationFlow = <TComposable extends Composable, DefaultT extends CreateBrowserRegistrationFlowResponse = CreateBrowserRegistrationFlowResponse>(options: Options<TComposable, CreateBrowserRegistrationFlowData, CreateBrowserRegistrationFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateBrowserRegistrationFlowResponse | DefaultT, CreateBrowserRegistrationFlowError, DefaultT>({
        url: '/self-service/registration/browser',
        ...options
    });
};

/**
 * Get Registration Flow
 * This endpoint returns a registration flow's context with, for example, error details and other information.
 *
 * Browser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.
 * For AJAX requests you must ensure that cookies are included in the request or requests will fail.
 *
 * If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain
 * and you need to forward the incoming HTTP Cookie header to this endpoint:
 *
 * ```js
 * pseudo-code example
 * router.get('/registration', async function (req, res) {
 * const flow = await client.getRegistrationFlow(req.header('cookie'), req.query['flow'])
 *
 * res.render('registration', flow)
 * })
 * ```
 *
 * This request may fail due to several reasons. The `error.id` can be one of:
 *
 * `session_already_available`: The user is already signed in.
 * `self_service_flow_expired`: The flow is expired and you should request a new one.
 *
 * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
 */
export const getRegistrationFlow = <TComposable extends Composable, DefaultT extends GetRegistrationFlowResponse = GetRegistrationFlowResponse>(options: Options<TComposable, GetRegistrationFlowData, GetRegistrationFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetRegistrationFlowResponse | DefaultT, GetRegistrationFlowError, DefaultT>({
        url: '/self-service/registration/flows',
        ...options
    });
};

/**
 * Complete Settings Flow
 * Use this endpoint to complete a settings flow by sending an identity's updated password. This endpoint
 * behaves differently for API and browser flows.
 *
 * API-initiated flows expect `application/json` to be sent in the body and respond with
 * HTTP 200 and an application/json body with the session token on success;
 * HTTP 303 redirect to a fresh settings flow if the original flow expired with the appropriate error messages set;
 * HTTP 400 on form validation errors.
 * HTTP 401 when the endpoint is called without a valid session token.
 * HTTP 403 when `selfservice.flows.settings.privileged_session_max_age` was reached or the session's AAL is too low.
 * Implies that the user needs to re-authenticate.
 *
 * Browser flows without HTTP Header `Accept` or with `Accept: text*` respond with
 * a HTTP 303 redirect to the post/after settings URL or the `return_to` value if it was set and if the flow succeeded;
 * a HTTP 303 redirect to the Settings UI URL with the flow ID containing the validation errors otherwise.
 * a HTTP 303 redirect to the login endpoint when `selfservice.flows.settings.privileged_session_max_age` was reached or the session's AAL is too low.
 *
 * Browser flows with HTTP Header `Accept: application/json` respond with
 * HTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success;
 * HTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set;
 * HTTP 401 when the endpoint is called without a valid session cookie.
 * HTTP 403 when the page is accessed without a session cookie or the session's AAL is too low.
 * HTTP 400 on form validation errors.
 *
 * Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator
 * Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn
 * credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user
 * to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.
 *
 * If this endpoint is called with a `Accept: application/json` HTTP header, the response contains the flow without a redirect. In the
 * case of an error, the `error.id` of the JSON response body can be one of:
 *
 * `session_refresh_required`: The identity requested to change something that needs a privileged session. Redirect
 * the identity to the login init endpoint with query parameters `?refresh=true&return_to=<the-current-browser-url>`,
 * or initiate a refresh login flow otherwise.
 * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
 * `session_inactive`: No Ory Session was found - sign in a user first.
 * `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other
 * identity logged in instead.
 * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
 * `browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL.
 * Most likely used in Social Sign In flows.
 *
 * More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
 */
export const updateSettingsFlow = <TComposable extends Composable, DefaultT extends UpdateSettingsFlowResponse = UpdateSettingsFlowResponse>(options: Options<TComposable, UpdateSettingsFlowData, UpdateSettingsFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).post<TComposable, UpdateSettingsFlowResponse | DefaultT, UpdateSettingsFlowError, DefaultT>({
        url: '/self-service/settings',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create Settings Flow for Native Apps
 * This endpoint initiates a settings flow for API clients such as mobile devices, smart TVs, and so on.
 * You must provide a valid Ory Kratos Session Token for this endpoint to respond with HTTP 200 OK.
 *
 * To fetch an existing settings flow call `/self-service/settings/flows?flow=<flow_id>`.
 *
 * You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
 * Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
 * you vulnerable to a variety of CSRF attacks.
 *
 * Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator
 * Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn
 * credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user
 * to sign in with the second factor or change the configuration.
 *
 * In the case of an error, the `error.id` of the JSON response body can be one of:
 *
 * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
 * `session_inactive`: No Ory Session was found - sign in a user first.
 *
 * This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
 *
 * More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
 */
export const createNativeSettingsFlow = <TComposable extends Composable, DefaultT extends CreateNativeSettingsFlowResponse = CreateNativeSettingsFlowResponse>(options: Options<TComposable, CreateNativeSettingsFlowData, CreateNativeSettingsFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateNativeSettingsFlowResponse | DefaultT, CreateNativeSettingsFlowError, DefaultT>({
        url: '/self-service/settings/api',
        ...options
    });
};

/**
 * Create Settings Flow for Browsers
 * This endpoint initializes a browser-based user settings flow. Once initialized, the browser will be redirected to
 * `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid
 * Ory Kratos Session Cookie is included in the request, a login flow will be initialized.
 *
 * If this endpoint is opened as a link in the browser, it will be redirected to
 * `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid user session
 * was set, the browser will be redirected to the login endpoint.
 *
 * If this endpoint is called via an AJAX request, the response contains the settings flow without any redirects
 * or a 401 forbidden error if no valid session was set.
 *
 * Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator
 * Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn
 * credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user
 * to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.
 *
 * If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the
 * case of an error, the `error.id` of the JSON response body can be one of:
 *
 * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
 * `session_inactive`: No Ory Session was found - sign in a user first.
 * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
 *
 * This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.
 *
 * More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
 */
export const createBrowserSettingsFlow = <TComposable extends Composable, DefaultT extends CreateBrowserSettingsFlowResponse = CreateBrowserSettingsFlowResponse>(options: Options<TComposable, CreateBrowserSettingsFlowData, CreateBrowserSettingsFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateBrowserSettingsFlowResponse | DefaultT, CreateBrowserSettingsFlowError, DefaultT>({
        url: '/self-service/settings/browser',
        ...options
    });
};

/**
 * Get Settings Flow
 * When accessing this endpoint through Ory Kratos' Public API you must ensure that either the Ory Kratos Session Cookie
 * or the Ory Kratos Session Token are set.
 *
 * Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator
 * Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn
 * credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user
 * to sign in with the second factor or change the configuration.
 *
 * You can access this endpoint without credentials when using Ory Kratos' Admin API.
 *
 * If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the
 * case of an error, the `error.id` of the JSON response body can be one of:
 *
 * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
 * `session_inactive`: No Ory Session was found - sign in a user first.
 * `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other
 * identity logged in instead.
 *
 * More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
 */
export const getSettingsFlow = <TComposable extends Composable, DefaultT extends GetSettingsFlowResponse = GetSettingsFlowResponse>(options: Options<TComposable, GetSettingsFlowData, GetSettingsFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetSettingsFlowResponse | DefaultT, GetSettingsFlowError, DefaultT>({
        url: '/self-service/settings/flows',
        ...options
    });
};

/**
 * Complete Verification Flow
 * Use this endpoint to complete a verification flow. This endpoint
 * behaves differently for API and browser flows and has several states:
 *
 * `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent
 * and works with API- and Browser-initiated flows.
 * For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid
 * and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired).
 * For Browser clients without HTTP Header `Accept` or with `Accept: text*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended.
 * `sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It
 * works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state.
 * `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow ("sending a verification link")
 * does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL
 * (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with
 * a new Verification Flow ID which contains an error message that the verification link was invalid.
 *
 * More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
 */
export const updateVerificationFlow = <TComposable extends Composable, DefaultT extends UpdateVerificationFlowResponse = UpdateVerificationFlowResponse>(options: Options<TComposable, UpdateVerificationFlowData, UpdateVerificationFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).post<TComposable, UpdateVerificationFlowResponse | DefaultT, UpdateVerificationFlowError, DefaultT>({
        url: '/self-service/verification',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create Verification Flow for Native Apps
 * This endpoint initiates a verification flow for API clients such as mobile devices, smart TVs, and so on.
 *
 * To fetch an existing verification flow call `/self-service/verification/flows?flow=<flow_id>`.
 *
 * You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
 * Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
 * you vulnerable to a variety of CSRF attacks.
 *
 * This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
 *
 * More information can be found at [Ory Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
 */
export const createNativeVerificationFlow = <TComposable extends Composable, DefaultT extends CreateNativeVerificationFlowResponse = CreateNativeVerificationFlowResponse>(options: Options<TComposable, CreateNativeVerificationFlowData, CreateNativeVerificationFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateNativeVerificationFlowResponse | DefaultT, CreateNativeVerificationFlowError, DefaultT>({
        url: '/self-service/verification/api',
        ...options
    });
};

/**
 * Create Verification Flow for Browser Clients
 * This endpoint initializes a browser-based account verification flow. Once initialized, the browser will be redirected to
 * `selfservice.flows.verification.ui_url` with the flow ID set as the query parameter `?flow=`.
 *
 * If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects.
 *
 * This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).
 *
 * More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
 */
export const createBrowserVerificationFlow = <TComposable extends Composable, DefaultT extends CreateBrowserVerificationFlowResponse = CreateBrowserVerificationFlowResponse>(options: Options<TComposable, CreateBrowserVerificationFlowData, CreateBrowserVerificationFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, CreateBrowserVerificationFlowResponse | DefaultT, CreateBrowserVerificationFlowError, DefaultT>({
        url: '/self-service/verification/browser',
        ...options
    });
};

/**
 * Get Verification Flow
 * This endpoint returns a verification flow's context with, for example, error details and other information.
 *
 * Browser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.
 * For AJAX requests you must ensure that cookies are included in the request or requests will fail.
 *
 * If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain
 * and you need to forward the incoming HTTP Cookie header to this endpoint:
 *
 * ```js
 * pseudo-code example
 * router.get('/recovery', async function (req, res) {
 * const flow = await client.getVerificationFlow(req.header('cookie'), req.query['flow'])
 *
 * res.render('verification', flow)
 * })
 * ```
 *
 * More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
 */
export const getVerificationFlow = <TComposable extends Composable, DefaultT extends GetVerificationFlowResponse = GetVerificationFlowResponse>(options: Options<TComposable, GetVerificationFlowData, GetVerificationFlowResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetVerificationFlowResponse | DefaultT, GetVerificationFlowError, DefaultT>({
        url: '/self-service/verification/flows',
        ...options
    });
};

/**
 * Disable my other sessions
 * Calling this endpoint invalidates all except the current session that belong to the logged-in user.
 * Session data are not deleted.
 */
export const disableMyOtherSessions = <TComposable extends Composable, DefaultT extends DisableMyOtherSessionsResponse = DisableMyOtherSessionsResponse>(options: Options<TComposable, DisableMyOtherSessionsData, DisableMyOtherSessionsResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).delete<TComposable, DisableMyOtherSessionsResponse | DefaultT, DisableMyOtherSessionsError, DefaultT>({
        url: '/sessions',
        ...options
    });
};

/**
 * Get My Active Sessions
 * This endpoints returns all other active sessions that belong to the logged-in user.
 * The current session can be retrieved by calling the `/sessions/whoami` endpoint.
 */
export const listMySessions = <TComposable extends Composable, DefaultT extends ListMySessionsResponse = ListMySessionsResponse>(options: Options<TComposable, ListMySessionsData, ListMySessionsResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, ListMySessionsResponse | DefaultT, ListMySessionsError, DefaultT>({
        url: '/sessions',
        ...options
    });
};

/**
 * Exchange Session Token
 */
export const exchangeSessionToken = <TComposable extends Composable, DefaultT extends ExchangeSessionTokenResponse = ExchangeSessionTokenResponse>(options: Options<TComposable, ExchangeSessionTokenData, ExchangeSessionTokenResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, ExchangeSessionTokenResponse | DefaultT, ExchangeSessionTokenError, DefaultT>({
        url: '/sessions/token-exchange',
        ...options
    });
};

/**
 * Check Who the Current HTTP Session Belongs To
 * Uses the HTTP Headers in the GET request to determine (e.g. by using checking the cookies) who is authenticated.
 * Returns a session object in the body or 401 if the credentials are invalid or no credentials were sent.
 * When the request it successful it adds the user ID to the 'X-Kratos-Authenticated-Identity-Id' header
 * in the response.
 *
 * If you call this endpoint from a server-side application, you must forward the HTTP Cookie Header to this endpoint:
 *
 * ```js
 * pseudo-code example
 * router.get('/protected-endpoint', async function (req, res) {
 * const session = await client.toSession(undefined, req.header('cookie'))
 *
 * console.log(session)
 * })
 * ```
 *
 * When calling this endpoint from a non-browser application (e.g. mobile app) you must include the session token:
 *
 * ```js
 * pseudo-code example
 * ...
 * const session = await client.toSession("the-session-token")
 *
 * console.log(session)
 * ```
 *
 * When using a token template, the token is included in the `tokenized` field of the session.
 *
 * ```js
 * pseudo-code example
 * ...
 * const session = await client.toSession("the-session-token", { tokenize_as: "example-jwt-template" })
 *
 * console.log(session.tokenized) // The JWT
 * ```
 *
 * Depending on your configuration this endpoint might return a 403 status code if the session has a lower Authenticator
 * Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn
 * credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user
 * to sign in with the second factor or change the configuration.
 *
 * This endpoint is useful for:
 *
 * AJAX calls. Remember to send credentials and set up CORS correctly!
 * Reverse proxies and API Gateways
 * Server-side calls - use the `X-Session-Token` header!
 *
 * This endpoint authenticates users by checking:
 *
 * if the `Cookie` HTTP header was set containing an Ory Kratos Session Cookie;
 * if the `Authorization: bearer <ory-session-token>` HTTP header was set with a valid Ory Kratos Session Token;
 * if the `X-Session-Token` HTTP header was set with a valid Ory Kratos Session Token.
 *
 * If none of these headers are set or the cookie or token are invalid, the endpoint returns a HTTP 401 status code.
 *
 * As explained above, this request may fail due to several reasons. The `error.id` can be one of:
 *
 * `session_inactive`: No active session was found in the request (e.g. no Ory Session Cookie / Ory Session Token).
 * `session_aal2_required`: An active session was found but it does not fulfil the Authenticator Assurance Level, implying that the session must (e.g.) authenticate the second factor.
 */
export const toSession = <TComposable extends Composable, DefaultT extends ToSessionResponse = ToSessionResponse>(options: Options<TComposable, ToSessionData, ToSessionResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, ToSessionResponse | DefaultT, ToSessionError, DefaultT>({
        url: '/sessions/whoami',
        ...options
    });
};

/**
 * Disable one of my sessions
 * Calling this endpoint invalidates the specified session. The current session cannot be revoked.
 * Session data are not deleted.
 */
export const disableMySession = <TComposable extends Composable, DefaultT extends DisableMySessionResponse = DisableMySessionResponse>(options: Options<TComposable, DisableMySessionData, DisableMySessionResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).delete<TComposable, DisableMySessionResponse | DefaultT, DisableMySessionError, DefaultT>({
        url: '/sessions/{id}',
        ...options
    });
};

/**
 * Return Running Software Version.
 * This endpoint returns the version of Ory Kratos.
 *
 * If the service supports TLS Edge Termination, this endpoint does not require the
 * `X-Forwarded-Proto` header to be set.
 *
 * Be aware that if you are running multiple nodes of this service, the version will never
 * refer to the cluster state, only to a single instance.
 */
export const getVersion = <TComposable extends Composable, DefaultT extends GetVersionResponse = GetVersionResponse>(options: Options<TComposable, GetVersionData, GetVersionResponse, DefaultT>) => {
    return (options.client ?? _heyApiClient).get<TComposable, GetVersionResponse | DefaultT, unknown, DefaultT>({
        url: '/version',
        ...options
    });
};